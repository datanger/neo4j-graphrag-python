#!/usr/bin/env python3
"""
Demo script for MATLAB Extractor functionality.
Shows how to use the MATLAB extractor to process code and extract relationships.
"""

import asyncio
import os
from pathlib import Path
from neo4j_graphrag.experimental.components.code_extractor.matlab.matlab_extractor import MatlabExtractor
from neo4j_graphrag.experimental.components.types import TextChunk, TextChunks

class MockLLM:
    """Mock LLM for demonstration purposes."""
    
    async def generate(self, prompt: str) -> str:
        """Return a mock description."""
        return "Mock description generated by LLM"

async def demo_matlab_extractor():
    """Demonstrate MATLAB extractor functionality."""
    
    print("=== MATLAB Extractor Demo ===\n")
    
    # Create sample MATLAB code
    sample_code = """
% Sample MATLAB script with functions and variables
function [result, status] = process_data(input_data, params)
    % Process input data with given parameters
    if isfield(params, 'threshold')
        threshold = params.threshold;
    else
        threshold = 0.5;
    end
    
    % Calculate result
    result = input_data * threshold;
    
    % Check status
    if result > 10
        status = 'high';
    else
        status = 'low';
    end
    
    % Display result
    disp(['Result: ' num2str(result)]);
end

% Main script
data = [1, 2, 3, 4, 5];
config.threshold = 0.8;

% Call function
[output, state] = process_data(data, config);

% Use global variable
global shared_value;
shared_value = output * 2;

% Another function call
final_result = process_data(shared_value, config);
"""
    
    # Create a temporary file
    temp_file = Path("demo_script.m")
    with open(temp_file, "w") as f:
        f.write(sample_code)
    
    try:
        # Set up extractor
        mock_llm = MockLLM()
        extractor = MatlabExtractor(
            llm=mock_llm,
            on_error='raise',
            create_lexical_graph=True,
            max_concurrency=5,
            debug=True
        )
        
        # Create text chunk
        chunk = TextChunk(
            text=sample_code,
            index=0,
            metadata={"file_path": str(temp_file)}
        )
        chunks = TextChunks(chunks=[chunk])
        
        # Process the code
        print("Processing MATLAB code...")
        result = await extractor.run(chunks=chunks)
        graph = result.graph
        
        # Display results
        print(f"\n=== Extraction Results ===")
        print(f"Total nodes: {len(graph.nodes)}")
        print(f"Total relationships: {len(graph.relationships)}")
        
        # Show nodes by type
        print(f"\n=== Nodes by Type ===")
        node_types = {}
        for node in graph.nodes:
            node_type = node.label
            if node_type not in node_types:
                node_types[node_type] = []
            node_types[node_type].append({
                'id': node.id,
                'name': node.properties.get('name', 'N/A'),
                'file': node.properties.get('file_path', 'N/A')
            })
        
        for node_type, nodes in node_types.items():
            print(f"\n{node_type} ({len(nodes)} nodes):")
            for node in nodes:
                print(f"  - {node['name']} (ID: {node['id']})")
                if node['file'] != 'N/A':
                    print(f"    File: {node['file']}")
        
        # Show relationships by type
        print(f"\n=== Relationships by Type ===")
        rel_types = {}
        for rel in graph.relationships:
            rel_type = rel.type
            if rel_type not in rel_types:
                rel_types[rel_type] = []
            rel_types[rel_type].append({
                'source': rel.start_node_id,
                'target': rel.end_node_id,
                'line': rel.properties.get('line_number', 'N/A')
            })
        
        for rel_type, rels in rel_types.items():
            print(f"\n{rel_type} ({len(rels)} relationships):")
            for rel in rels[:5]:  # Show first 5
                print(f"  - {rel['source']} -> {rel['target']}")
                if rel['line'] != 'N/A':
                    print(f"    Line: {rel['line']}")
            if len(rels) > 5:
                print(f"    ... and {len(rels) - 5} more")
        
        # Show MATLAB-specific relationships
        matlab_edge_types = {'CALLS', 'USES', 'DEFINES', 'MODIFIES', 'ASSIGNED_TO'}
        matlab_rels = [rel for rel in graph.relationships if rel.type in matlab_edge_types]
        
        print(f"\n=== MATLAB-Specific Relationships ===")
        print(f"Total MATLAB relationships: {len(matlab_rels)}")
        
        for rel_type in matlab_edge_types:
            type_rels = [rel for rel in matlab_rels if rel.type == rel_type]
            if type_rels:
                print(f"\n{rel_type} ({len(type_rels)} relationships):")
                for rel in type_rels:
                    source_name = next((n.properties.get('name', rel.start_node_id) 
                                      for n in graph.nodes if n.id == rel.start_node_id), rel.start_node_id)
                    target_name = next((n.properties.get('name', rel.end_node_id) 
                                      for n in graph.nodes if n.id == rel.end_node_id), rel.end_node_id)
                    print(f"  - {source_name} -> {target_name}")
                    if rel.properties.get('line_number'):
                        print(f"    Line: {rel.properties['line_number']}")
        
        # Check for duplicates
        print(f"\n=== Duplicate Check ===")
        node_ids = [node.id for node in graph.nodes]
        unique_node_ids = set(node_ids)
        print(f"Nodes: {len(node_ids)} total, {len(unique_node_ids)} unique")
        print("✅ No duplicate nodes" if len(node_ids) == len(unique_node_ids) else "❌ Found duplicate nodes")
        
        edge_keys = [(rel.start_node_id, rel.end_node_id, rel.type, rel.properties.get('line_number')) 
                     for rel in matlab_rels]
        unique_edge_keys = set(edge_keys)
        print(f"MATLAB edges: {len(edge_keys)} total, {len(unique_edge_keys)} unique")
        print("✅ No duplicate MATLAB edges" if len(edge_keys) == len(unique_edge_keys) else "❌ Found duplicate MATLAB edges")
        
    finally:
        # Clean up
        if temp_file.exists():
            temp_file.unlink()
    
    print(f"\n=== Demo Complete ===")
    print("The MATLAB extractor successfully processed the sample code and extracted:")
    print("- Function definitions and their parameters")
    print("- Variable definitions and assignments")
    print("- Function calls and their relationships")
    print("- Variable usage patterns")
    print("- Global variable declarations")
    print("- All without creating duplicate nodes or relationships!")

if __name__ == "__main__":
    asyncio.run(demo_matlab_extractor()) 