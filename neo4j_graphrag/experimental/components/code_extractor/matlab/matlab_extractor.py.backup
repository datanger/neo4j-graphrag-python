# Copyright (c) "Neo4j"
# Neo4j Sweden AB [https://neo4j.com]
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

import asyncio
import json
import logging
import os
import re
import numpy as np
from collections import defaultdict
from pathlib import Path
from typing import Any, Dict, List, Optional, Set, Tuple, Union

from neo4j_graphrag.llm import LLMInterface
from neo4j_graphrag.experimental.components.entity_relation_extractor import (
    LLMEntityRelationExtractor,
    OnError,
)
from neo4j_graphrag.experimental.components.schema import GraphSchema
from neo4j_graphrag.experimental.components.types import (
    TextChunk,
    TextChunks,
    Neo4jGraph,
    Neo4jNode,
    Neo4jRelationship
)
from neo4j_graphrag.experimental.pipeline.component import DataModel
from neo4j_graphrag.generation.prompts import ERExtractionTemplate
from pydantic import ValidationError

# Define a custom return type that inherits from DataModel
class MatlabExtractionResult(DataModel):
    """Result model for MATLAB code extraction."""
    graph: Neo4jGraph

logger = logging.getLogger(__name__)

# Global registry for cross-file relationships
class GlobalMatlabRegistry:
    """Global registry to track all MATLAB entities across files for post-processing."""

    def __init__(self):
        self.scripts = {}  # script_name -> script_node
        self.functions = {}  # func_name -> func_node
        self.all_nodes = []  # All nodes from all files
        self.all_edges = []  # All edges from all files
        self.call_sites = []  # All call sites for post-processing
        self.file_contents = {}  # file_path -> content for cross-file analysis
        # 新增：执行顺序分析相关
        self.execution_order = []  # 脚本执行顺序
        self.variable_definitions_by_script = {}  # script_name -> {var_name: line_number}
        self.variable_usage_by_script = {}  # script_name -> {var_name: line_number}
        self.script_dependencies = {}  # script_name -> [dependent_scripts]
        # 新增：启动脚本支持
        self.entry_script_path = None  # 启动脚本路径
        self.entry_script_content = None  # 启动脚本内容
        self.entry_script_execution_flow = []  # 启动脚本执行流程
        self.entry_script_variable_scope = {}  # 启动脚本中的变量作用域

    def set_entry_script(self, script_path: str, script_content: str = None):
        """设置启动脚本，用于分析执行流程和变量作用域。
        
        Args:
            script_path: 启动脚本的路径
            script_content: 启动脚本的内容，如果为None则从文件读取
        """
        self.entry_script_path = script_path
        if script_content is None:
            try:
                with open(script_path, 'r', encoding='utf-8') as f:
                    self.entry_script_content = f.read()
            except Exception as e:
                logger.error(f"Failed to read entry script {script_path}: {e}")
                self.entry_script_content = ""
        else:
            self.entry_script_content = script_content
        
        # 分析启动脚本的执行流程
        self._analyze_entry_script_execution_flow()

    def _analyze_entry_script_execution_flow(self):
        """分析启动脚本的执行流程，确定脚本调用顺序和变量作用域。"""
        if not self.entry_script_content:
            return
        
        lines = self.entry_script_content.split('\n')
        current_scope = "entry_script"
        self.entry_script_execution_flow = []
        self.entry_script_variable_scope = {}
        
        for line_num, line in enumerate(lines, 1):
            line = line.strip()
            if not line or line.startswith('%'):
                continue
            
            # 检测脚本调用
            script_call_match = re.match(r'^\s*([a-zA-Z_]\w*)\s*;', line)
            if script_call_match:
                script_name = script_call_match.group(1)
                self.entry_script_execution_flow.append({
                    'type': 'script_call',
                    'script_name': script_name,
                    'line_number': line_num,
                    'scope': current_scope
                })
                continue
            
            # 检测run()调用
            run_call_match = re.search(r"run\s*\(\s*['\"]([^'\"]+)['\"]\s*\)", line)
            if run_call_match:
                script_name = run_call_match.group(1)
                self.entry_script_execution_flow.append({
                    'type': 'run_call',
                    'script_name': script_name,
                    'line_number': line_num,
                    'scope': current_scope
                })
                continue
            
            # 检测变量定义
            var_def_match = re.match(r'^\s*([a-zA-Z_]\w*)\s*=', line)
            if var_def_match:
                var_name = var_def_match.group(1)
                if var_name not in self.entry_script_variable_scope:
                    self.entry_script_variable_scope[var_name] = {
                        'defined_at': line_num,
                        'scope': current_scope,
                        'usage_lines': []
                    }
                continue
            
            # 检测变量使用
            for var_name in self.entry_script_variable_scope.keys():
                if re.search(r'\b' + re.escape(var_name) + r'\b', line):
                    self.entry_script_variable_scope[var_name]['usage_lines'].append(line_num)
        
        logger.info(f"Entry script execution flow: {len(self.entry_script_execution_flow)} calls, {len(self.entry_script_variable_scope)} variables")

    def get_entry_script_execution_order(self) -> List[str]:
        """根据启动脚本获取执行顺序。"""
        if not self.entry_script_execution_flow:
            return []
        
        execution_order = []
        seen_scripts = set()
        
        # 按照启动脚本中的调用顺序构建执行顺序
        for call in self.entry_script_execution_flow:
            script_name = call['script_name']
            if script_name not in seen_scripts:
                execution_order.append(script_name)
                seen_scripts.add(script_name)
        
        return execution_order

    def get_entry_script_variable_source(self, var_name: str, usage_script: str) -> Optional[str]:
        """根据启动脚本确定变量的来源脚本。
        
        Args:
            var_name: 变量名
            usage_script: 使用该变量的脚本名
            
        Returns:
            定义该变量的脚本名，如果无法确定则返回None
        """
        if not self.entry_script_execution_flow:
            return None
        
        # 检查变量是否在启动脚本中定义
        if var_name in self.entry_script_variable_scope:
            return "entry_script"
        
        # 根据执行顺序查找变量来源
        execution_order = self.get_entry_script_execution_order()
        if usage_script not in execution_order:
            return None
        
        usage_index = execution_order.index(usage_script)
        
        # 在usage_script之前执行的脚本中查找变量定义
        for i in range(usage_index):
            candidate_script = execution_order[i]
            if (candidate_script in self.variable_definitions_by_script and 
                var_name in self.variable_definitions_by_script[candidate_script]):
                return candidate_script
        
        return None

    def register_script(self, script_name: str, script_node: dict):
        """Register a script node."""
        self.scripts[script_name] = script_node

    def register_function(self, func_name: str, func_node: dict):
        """Register a function node."""
        self.functions[func_name] = func_node

    def add_nodes(self, nodes: List[dict]):
        """Add nodes from a file."""
        self.all_nodes.extend(nodes)

    def add_edges(self, edges: List[dict]):
        """Add edges from a file."""
        self.all_edges.extend(edges)

    def add_call_sites(self, call_sites: List[dict]):
        """Add call sites for post-processing."""
        self.call_sites.extend(call_sites)

    def register_file_content(self, file_path: str, content: str):
        """Register file content for cross-file analysis."""
        self.file_contents[file_path] = content

    def register_variable_definition(self, script_name: str, var_name: str, line_number: int):
        """Register a variable definition in a script."""
        if script_name not in self.variable_definitions_by_script:
            self.variable_definitions_by_script[script_name] = {}
        self.variable_definitions_by_script[script_name][var_name] = line_number

    def register_variable_usage(self, script_name: str, var_name: str, line_number: int):
        """Register a variable usage in a script."""
        if script_name not in self.variable_usage_by_script:
            self.variable_usage_by_script[script_name] = {}
        if var_name not in self.variable_usage_by_script[script_name]:
            self.variable_usage_by_script[script_name][var_name] = []
        self.variable_usage_by_script[script_name][var_name].append(line_number)

    def register_script_dependency(self, caller_script: str, callee_script: str):
        """Register a dependency between scripts."""
        if caller_script not in self.script_dependencies:
            self.script_dependencies[caller_script] = []
        if callee_script not in self.script_dependencies[caller_script]:
            self.script_dependencies[caller_script].append(callee_script)

    def analyze_execution_order(self):
        """Analyze the execution order of scripts based on dependencies."""
        # 如果有启动脚本，优先使用启动脚本的执行顺序
        if self.entry_script_execution_flow:
            entry_order = self.get_entry_script_execution_order()
            if entry_order:
                self.execution_order = entry_order
                logger.info(f"Using entry script execution order: {entry_order}")
                return entry_order
        
        # 否则使用拓扑排序确定执行顺序
        in_degree = {script: 0 for script in self.scripts.keys()}
        
        # 计算入度
        for caller, callees in self.script_dependencies.items():
            for callee in callees:
                if callee in in_degree:
                    in_degree[callee] += 1
        
        # 拓扑排序
        queue = [script for script, degree in in_degree.items() if degree == 0]
        execution_order = []
        
        while queue:
            current = queue.pop(0)
            execution_order.append(current)
            
            if current in self.script_dependencies:
                for callee in self.script_dependencies[current]:
                    in_degree[callee] -= 1
                    if in_degree[callee] == 0:
                        queue.append(callee)
        
        self.execution_order = execution_order
        return execution_order

    def can_access_variable(self, caller_script: str, var_name: str, usage_line: int) -> bool:
        """Check if a script can access a variable based on execution order."""
        if caller_script not in self.execution_order:
            return False
            
        caller_index = self.execution_order.index(caller_script)
        
        # 检查是否有其他脚本在调用者之前定义了该变量
        for script_name in self.execution_order[:caller_index]:
            if (script_name in self.variable_definitions_by_script and 
                var_name in self.variable_definitions_by_script[script_name]):
                def_line = self.variable_definitions_by_script[script_name][var_name]
                return True  # 变量在调用者之前被定义
        
        return False

    def get_variable_source_script(self, var_name: str, caller_script: str) -> Optional[str]:
        """Get the script that defines a variable, considering execution order."""
        # 如果有启动脚本，优先使用启动脚本的分析
        if self.entry_script_execution_flow:
            source = self.get_entry_script_variable_source(var_name, caller_script)
            if source:
                return source
        
        if caller_script not in self.execution_order:
            return None
            
        caller_index = self.execution_order.index(caller_script)
        
        # 从最近的脚本开始查找
        for script_name in reversed(self.execution_order[:caller_index]):
            if (script_name in self.variable_definitions_by_script and 
                var_name in self.variable_definitions_by_script[script_name]):
                return script_name
        
        return None

# Global instance
_global_registry = GlobalMatlabRegistry()

# Constants for MATLAB code analysis
MATLAB_KEYWORDS = {
    "if", "else", "elseif", "end", "for", "while", "switch", "case", "otherwise",
    "try", "catch", "function", "return", "global", "persistent", "classdef",
    "properties", "methods", "events", "parfor", "spmd", "is"
}

# Load MATLAB built-in functions
with open(Path(__file__).parent / "matlab_builtin_functions.json", "r") as f:
    MATLAB_BUILTINS = json.load(f)

COMMON_WORDS_TO_IGNORE = {
    "on", "off", "assign", "assigns", "define", "defines", "use", "uses",
    "variable", "variables", "parameter", "parameters",
    "script", "local", "global", "calculation", "value",
    "test", "file", "path", "content", "line", "range", "preview",
    "dependencies", "generates", "description", "type", "id", "source",
    "target", "label", "node", "edge", "graph", "element", "elements",
    "start", "if", "for", "while", "loop", "iter", "count", "index",
    "idx", "step", "endfor", "endif", "is", "i", "j", "k", "x", "y", "z",
    # Add more common English words found in comments
    "that", "this", "the", "are", "and", "calls", "which", "with", "from",
    "demonstrates", "helper", "main", "function"
}

IDENTIFIERS_TO_EXCLUDE = set(MATLAB_KEYWORDS).union(set(MATLAB_BUILTINS)).union(COMMON_WORDS_TO_IGNORE)

class MatlabExtractor(LLMEntityRelationExtractor):
    """MATLAB-specific entity and relationship extractor."""

    def __init__(
        self,
        llm: Optional[LLMInterface] = None,
        on_error: OnError = OnError.IGNORE,
        create_lexical_graph: bool = True,
        max_concurrency: int = 5,
        debug: bool = False,
        enable_post_processing: bool = True,
        entry_script_path: Optional[str] = None,  # 新增：启动脚本路径
        use_llm: bool = False,  # 新增：是否使用LLM，默认False使用纯Python实现
    ):
        """Initialize the MATLAB extractor.

        Args:
            llm: Language model interface
            on_error: Error handling strategy
            create_lexical_graph: Whether to create lexical graph
            max_concurrency: Maximum concurrent processing
            debug: Enable debug mode
            enable_post_processing: Enable post-processing for cross-file relationships
            entry_script_path: Path to the entry script for execution flow analysis
        """
        super().__init__(
            llm=llm,
            on_error=on_error,
            create_lexical_graph=create_lexical_graph,
            max_concurrency=max_concurrency,
        )
        self.debug = debug
        self.enable_post_processing = enable_post_processing
        self.entry_script_path = entry_script_path  # 新增：启动脚本路径
        self.use_llm = use_llm  # 新增：是否使用LLM
        
        # 如果提供了启动脚本路径，设置到全局注册表
        if entry_script_path:
            _global_registry.set_entry_script(entry_script_path)
            logger.info(f"Entry script set: {entry_script_path}")
        
        # Initialize state
        self._reset_state()

    def _node_exists(self, node_id: str) -> bool:
        """Check if a node with the given ID already exists."""
        return any(n.get('id') == node_id for n in self.nodes)

    def _add_node_if_not_exists(self, node_data: dict) -> None:
        """Add a node only if it doesn't already exist."""
        node_id = node_data.get('id')
        if node_id and not self._node_exists(node_id):
            self.nodes.append(node_data)
        elif self.debug and node_id:
            print(f"[DEBUG] Skipping duplicate node: {node_id}")

    def _ensure_neo4j_compatible(self, value):
        """Ensure value is Neo4j-compatible type"""
        if value is None:
            return None

        # Handle numpy types
        if hasattr(value, 'item') and hasattr(value, 'dtype'):
            try:
                value = value.item()
            except:
                return str(value)

        # Handle standard Python types
        if isinstance(value, (bool, np.bool_)):
            return bool(value)
        elif isinstance(value, (int, np.integer)):
            return int(value)
        elif isinstance(value, (float, np.floating)):
            if float(value).is_integer():
                return int(value)
            return float(value)
        elif isinstance(value, (list, tuple)):
            return [self._ensure_neo4j_compatible(x) for x in value]
        elif isinstance(value, dict):
            return {str(k): self._ensure_neo4j_compatible(v) for k, v in value.items()}
        elif isinstance(value, str):
            return value
        else:
            return str(value)

    async def extract_for_chunk(
        self, schema: GraphSchema, examples: str, chunk: TextChunk
    ) -> Neo4jGraph:
        """Extract entities and relationships from a single chunk of MATLAB code."""
        self.text = chunk.text
        self.path = chunk.metadata.get("file_path", "")
        self.lines = self.text.splitlines()
        # Reset state for this chunk
        self._reset_state()

        # Always register file content for potential cross-file analysis later
        _global_registry.register_file_content(self.path, self.text)

        # --- 第一遍：只创建脚本节点 ---
        script_name = os.path.basename(self.path)
        if script_name.endswith('.m'):
            script_id = f"script_{script_name}"
            if not self._node_exists(script_id):
                script_node = {
                    "id": script_id,
                    "label": "Script",
                    "name": script_name,
                    "file_path": self.path,
                    "description": "",
                    "line_range": ("", 1, len(self.lines))
                }
                self._add_node_if_not_exists(script_node)

                # Always register script in global registry
                _global_registry.register_script(script_name, script_node)

        # --- 第二遍：正常处理内容和关系 ---
        self._parse_matlab_code()

        # Always register nodes and edges in global registry for post-processing
        _global_registry.add_nodes(self.nodes)
        _global_registry.add_edges(self.edges)

        # Always register functions found in this file
        for node in self.nodes:
            if node.get('label') == 'Function':
                func_name = node.get('name')
                if func_name:
                    _global_registry.register_function(func_name, node)

        # Clean up any remaining duplicates
        self._cleanup_duplicates()

        # Create Neo4jGraph instance
        graph = Neo4jGraph()
        # Add nodes with proper types and properties
        for node in self.nodes:
            try:
                node_label = node.get("label")
                node_id = node.get("id")
                properties = {
                    str(k): self._ensure_neo4j_compatible(v)
                    for k, v in node.items()
                    if k not in ["id", "label", "type"]
                }
                if node_label == "Variable" and "line_range" in properties:
                    line_range = properties["line_range"]
                    if isinstance(line_range, str):
                        try:
                            start, end = map(int, line_range.split('-'))
                            properties["line_range"] = [("", start, end)]
                        except:
                            properties["line_range"] = []
                graph.nodes.append(
                    Neo4jNode(
                        id=str(node_id),
                        label=str(node_label),
                        properties=properties
                    )
                )
            except Exception as e:
                logger.warning(f"Error processing node {node.get('id')}: {str(e)}")
                continue
        for edge in self.edges:
            try:
                source_id = edge.get("source")
                target_id = edge.get("target")
                rel_type = edge.get("label")
                if not all([source_id, target_id, rel_type]):
                    continue
                graph.relationships.append(
                    Neo4jRelationship(
                        start_node_id=str(source_id),
                        end_node_id=str(target_id),
                        type=str(rel_type),
                        properties={
                            k: self._ensure_neo4j_compatible(v)
                            for k, v in edge.get("properties", {}).items()
                        }
                    )
                )
            except Exception as e:
                logger.warning(f"Error processing edge {edge.get('source')} -> {edge.get('target')}: {str(e)}")
                continue
        logger.debug(f"Successfully created graph with {len(graph.nodes)} nodes and {len(graph.relationships)} relationships")
        return graph

    @classmethod
    def post_process_cross_file_relationships(cls, graph: Neo4jGraph) -> Neo4jGraph:
        """Post-process the graph to add cross-file script-to-script and script-to-function relationships.

        This method should be called after all files have been processed to establish
        cross-file relationships that couldn't be detected during single-file processing.

        Args:
            graph: The Neo4jGraph to post-process

        Returns:
            Neo4jGraph: The updated graph with cross-file relationships
        """
        if not _global_registry.scripts and not _global_registry.functions:
            logger.warning("No scripts or functions registered for post-processing")
            return graph

        logger.info(f"Post-processing cross-file relationships with {len(_global_registry.scripts)} scripts and {len(_global_registry.functions)} functions")

        # 分析执行顺序
        execution_order = _global_registry.analyze_execution_order()
        logger.info(f"Determined execution order: {execution_order}")

        # Create a mapping of node IDs to nodes for quick lookup
        node_map = {node.id: node for node in graph.nodes}

        # Process each file's content to find cross-file calls
        for file_path, content in _global_registry.file_contents.items():
            script_name = os.path.basename(file_path)
            if not script_name.endswith('.m'):
                continue

            # Find the script node for this file
            script_node = None
            for node in graph.nodes:
                if (node.label == "Script" and
                    node.properties.get("name") == script_name):
                    script_node = node
                    break

            if not script_node:
                continue

            # Find script calls in this file
            cls._find_script_calls_in_content(content, script_node, node_map, graph)

            # Find function calls in this file
            cls._find_function_calls_in_content(content, script_node, node_map, graph)

        # 处理基于执行顺序的跨作用域变量访问
        cls._process_execution_order_variable_access(graph, execution_order)
        
        # 如果有启动脚本，处理启动脚本的跨作用域变量访问
        if _global_registry.entry_script_path:
            cls._process_entry_script_variable_access(graph)

        logger.info(f"Post-processing complete. Graph now has {len(graph.relationships)} relationships")
        return graph

    @classmethod
    def _process_entry_script_variable_access(cls, graph: Neo4jGraph):
        """处理启动脚本的跨作用域变量访问。"""
        if not _global_registry.entry_script_execution_flow:
            return
            
        logger.info("Processing entry script-based variable access...")
        
        # 为启动脚本中的变量创建节点（如果不存在）
        entry_script_node_id = "script_entry_script"
        entry_script_node = None
        
        # 检查启动脚本节点是否已存在
        for node in graph.nodes:
            if node.id == entry_script_node_id:
                entry_script_node = node
                break
        
        # 如果不存在，创建启动脚本节点
        if not entry_script_node:
            entry_script_node = Neo4jNode(
                id=entry_script_node_id,
                label="Script",
                properties={
                    "name": os.path.basename(_global_registry.entry_script_path),
                    "file_path": _global_registry.entry_script_path,
                    "description": "Entry script for execution flow analysis"
                }
            )
            graph.nodes.append(entry_script_node)
            logger.info(f"Created entry script node: {entry_script_node_id}")
        
        # 为启动脚本中定义的变量创建节点
        for var_name, var_info in _global_registry.entry_script_variable_scope.items():
            var_id = f"var_{var_name}_script_entry_script"
            
            # 检查变量节点是否已存在
            var_node_exists = any(node.id == var_id for node in graph.nodes)
            
            if not var_node_exists:
                var_node = Neo4jNode(
                    id=var_id,
                    label="Variable",
                    properties={
                        "name": var_name,
                        "file_path": _global_registry.entry_script_path,
                        "scope_id": "script_entry_script",
                        "scope_type": "script",
                        "line_range": f"entry script at line {var_info['defined_at']}"
                    }
                )
                graph.nodes.append(var_node)
                
                # 创建DEFINES关系
                graph.relationships.append(
                    Neo4jRelationship(
                        start_node_id=entry_script_node_id,
                        end_node_id=var_id,
                        type="DEFINES",
                        properties={
                            "type": "variable_definition",
                            "line_number": var_info['defined_at'],
                            "post_processed": True
                        }
                    )
                )
                logger.debug(f"Created entry script variable: {var_name}")
        
        # 处理启动脚本执行流程中的跨作用域变量访问
        execution_order = _global_registry.get_entry_script_execution_order()
        
        for script_name in execution_order:
            script_node_id = f"script_{script_name}"
            
            # 检查脚本节点是否存在
            script_node = None
            for node in graph.nodes:
                if node.id == script_node_id:
                    script_node = node
                    break
            
            if not script_node:
                logger.warning(f"Script node not found for {script_name}")
                continue
            
            # 检查该脚本中使用的变量
            if script_name in _global_registry.variable_usage_by_script:
                for var_name, usage_lines in _global_registry.variable_usage_by_script[script_name].items():
                    # 查找变量来源
                    source_script = _global_registry.get_entry_script_variable_source(var_name, script_name)
                    
                    if source_script:
                        if source_script == "entry_script":
                            # 变量来自启动脚本
                            source_var_id = f"var_{var_name}_script_entry_script"
                        else:
                            # 变量来自其他脚本
                            source_var_id = f"var_{var_name}_script_{source_script}"
                        
                        # 检查关系是否已存在
                        existing_edge = next(
                            (rel for rel in graph.relationships
                             if (rel.start_node_id == script_node_id and
                                 rel.end_node_id == source_var_id and
                                 rel.type == "USES")),
                            None
                        )
                        
                        if not existing_edge:
                            # 创建跨作用域的USES关系
                            graph.relationships.append(
                                Neo4jRelationship(
                                    start_node_id=script_node_id,
                                    end_node_id=source_var_id,
                                    type="USES",
                                    properties={
                                        "usage_type": "cross_scope_entry_script",
                                        "variable_name": var_name,
                                        "source_script": source_script,
                                        "target_script": script_name,
                                        "entry_script_guided": True,
                                        "post_processed": True
                                    }
                                )
                            )
                            logger.debug(f"Added entry script-guided USES: {script_name} -> {source_script}.{var_name}")
                            
                            # 创建跨作用域的ASSIGNED_TO关系来体现脚本间的依赖关系
                            target_var_id = f"var_{var_name}_script_{script_name}"
                            
                            # 检查目标变量节点是否存在，如果不存在则创建
                            target_var_exists = any(node.id == target_var_id for node in graph.nodes)
                            if not target_var_exists:
                                target_var_node = Neo4jNode(
                                    id=target_var_id,
                                    label="Variable",
                                    properties={
                                        "name": var_name,
                                        "file_path": f"script_{script_name}",
                                        "scope_id": f"script_{script_name}",
                                        "scope_type": "script",
                                        "line_range": f"cross_scope_usage"
                                    }
                                )
                                graph.nodes.append(target_var_node)
                                logger.debug(f"Created target variable node: {target_var_id}")
                            
                            # 创建ASSIGNED_TO关系
                            assigned_to_edge = Neo4jRelationship(
                                start_node_id=source_var_id,
                                end_node_id=target_var_id,
                                type="ASSIGNED_TO",
                                properties={
                                    "type": "cross_scope_assignment",
                                    "variable_name": var_name,
                                    "source_script": source_script,
                                    "target_script": script_name,
                                    "entry_script_guided": True,
                                    "post_processed": True
                                }
                            )
                            graph.relationships.append(assigned_to_edge)
                            logger.debug(f"Added cross-scope ASSIGNED_TO: {source_script}.{var_name} -> {script_name}.{var_name}")

    @classmethod
    def _process_execution_order_variable_access(cls, graph: Neo4jGraph, execution_order: List[str]):
        """Process cross-scope variable access based on execution order."""
        logger.info("Processing execution order-based variable access...")
        
        # 为每个脚本的变量使用创建跨作用域关系
        for script_name, var_usages in _global_registry.variable_usage_by_script.items():
            if script_name not in execution_order:
                continue
                
            for var_name, usage_lines in var_usages.items():
                # 检查是否有其他脚本在之前定义了该变量
                source_script = _global_registry.get_variable_source_script(var_name, script_name)
                
                if source_script:
                    # 找到源脚本的变量节点
                    source_var_id = f"var_{var_name}_script_{source_script}"
                    target_script_id = f"script_{script_name}"
                    
                    # 检查关系是否已存在
                    existing_edge = next(
                        (rel for rel in graph.relationships
                         if (rel.start_node_id == target_script_id and
                             rel.end_node_id == source_var_id and
                             rel.type == "USES")),
                        None
                    )
                    
                    if not existing_edge:
                        # 创建跨作用域的USES关系
                        graph.relationships.append(
                            Neo4jRelationship(
                                start_node_id=target_script_id,
                                end_node_id=source_var_id,
                                type="USES",
                                properties={
                                    "usage_type": "cross_scope_execution_order",
                                    "variable_name": var_name,
                                    "source_script": source_script,
                                    "target_script": script_name,
                                    "execution_order": execution_order.index(script_name),
                                    "source_execution_order": execution_order.index(source_script),
                                    "post_processed": True
                                }
                            )
                        )
                        logger.debug(f"Added execution order-based USES: {script_name} -> {source_script}.{var_name}")
                        
                        # 创建跨作用域的ASSIGNED_TO关系来体现脚本间的依赖关系
                        target_var_id = f"var_{var_name}_script_{script_name}"
                        
                        # 检查目标变量节点是否存在，如果不存在则创建
                        target_var_exists = any(node.id == target_var_id for node in graph.nodes)
                        if not target_var_exists:
                            target_var_node = Neo4jNode(
                                id=target_var_id,
                                label="Variable",
                                properties={
                                    "name": var_name,
                                    "file_path": f"script_{script_name}",
                                    "scope_id": f"script_{script_name}",
                                    "scope_type": "script",
                                    "line_range": f"cross_scope_usage"
                                }
                            )
                            graph.nodes.append(target_var_node)
                            logger.debug(f"Created target variable node: {target_var_id}")
                        
                        # 创建ASSIGNED_TO关系
                        assigned_to_edge = Neo4jRelationship(
                            start_node_id=source_var_id,
                            end_node_id=target_var_id,
                            type="ASSIGNED_TO",
                            properties={
                                "type": "cross_scope_assignment",
                                "variable_name": var_name,
                                "source_script": source_script,
                                "target_script": script_name,
                                "execution_order": execution_order.index(script_name),
                                "source_execution_order": execution_order.index(source_script),
                                "post_processed": True
                            }
                        )
                        graph.relationships.append(assigned_to_edge)
                        logger.debug(f"Added cross-scope ASSIGNED_TO: {source_script}.{var_name} -> {script_name}.{var_name}")

    @classmethod
    def _find_script_calls_in_content(cls, content: str, caller_node, node_map: dict, graph: Neo4jGraph):
        """Find script calls in the given content and add relationships."""
        lines = content.split('\n')

        for line_num, line in enumerate(lines, 1):
            line = line.strip()
            if not line or line.startswith('%'):
                continue

            # Pattern for direct script calls: script_name;
            script_call_match = re.match(r'^\s*([a-zA-Z_]\w*)\s*;', line)
            if script_call_match:
                script_name = script_call_match.group(1)
                if script_name.lower() not in IDENTIFIERS_TO_EXCLUDE:
                    found_script = False
                    for node in graph.nodes:
                        if (node.label == "Script" and (node.properties.get('name') == script_name or node.properties.get('name') == script_name + '.m')):
                            # Add CALLS relationship
                            graph.relationships.append(
                                Neo4jRelationship(
                                    start_node_id=caller_node.id,
                                    end_node_id=node.id,
                                    type="CALLS",
                                    properties={
                                        "call_type": "script_call",
                                        "script_name": script_name,
                                        "line_number": line_num,
                                        "post_processed": True
                                    }
                                )
                            )
                            found_script = True
                            logger.debug(f"Added cross-file script call: {caller_node.properties.get('name')} -> {script_name} at line {line_num}")
                            break
                    if not found_script:
                        logger.debug(f"Script '{script_name}' not found in nodes. Available scripts: {[n.properties.get('name') for n in graph.nodes if n.label == 'Script']}")
            run_call_match = re.search(r"run\s*\(\s*['\"]([^'\"]+)['\"]\s*\)", line)
            if run_call_match:
                script_name = run_call_match.group(1)
                if script_name.lower() not in IDENTIFIERS_TO_EXCLUDE:
                    found_script = False
                    for node in graph.nodes:
                        if (node.label == "Script" and (node.properties.get('name') == script_name or node.properties.get('name') == script_name.replace('.m', ''))):
                            # Add CALLS relationship
                            graph.relationships.append(
                                Neo4jRelationship(
                                    start_node_id=caller_node.id,
                                    end_node_id=node.id,
                                    type="CALLS",
                                    properties={
                                        "call_type": "run_call",
                                        "script_name": script_name,
                                        "line_number": line_num,
                                        "post_processed": True
                                    }
                                )
                            )
                            found_script = True
                            logger.debug(f"Added cross-file script call via run(): {caller_node.properties.get('name')} -> {script_name} at line {line_num}")
                            break
                    if not found_script:
                        logger.debug(f"Script '{script_name}' not found in nodes for run() call. Available scripts: {[n.properties.get('name') for n in graph.nodes if n.label == 'Script']}")

    @classmethod
    def _find_function_calls_in_content(cls, content: str, caller_node, node_map: dict, graph: Neo4jGraph):
        """Find function calls in the given content and add relationships."""
        lines = content.split('\n')

        for line_num, line in enumerate(lines, 1):
            line = line.strip()
            if not line or line.startswith('%'):
                continue

            # Pattern for function calls: func_name(...)
            func_call_match = re.search(r'(?<![\w.])([a-zA-Z_]\w*)\s*\([^)]*\)', line)
            if func_call_match:
                func_name = func_call_match.group(1)

                # Skip if this is a known keyword or built-in
                if func_name.lower() in IDENTIFIERS_TO_EXCLUDE:
                    continue

                # Find the called function
                called_func = None
                for node in graph.nodes:
                    if (node.label == "Function" and
                        node.properties.get("name") == func_name):
                        called_func = node
                        break

                if called_func:
                    # Check if this relationship already exists
                    existing_edge = next(
                        (rel for rel in graph.relationships
                         if (rel.start_node_id == caller_node.id and
                             rel.end_node_id == called_func.id and
                             rel.type == "CALLS" and
                             rel.properties.get("line_number") == line_num)),
                        None
                    )

                    if not existing_edge:
                        # Add CALLS relationship
                        graph.relationships.append(
                            Neo4jRelationship(
                                start_node_id=caller_node.id,
                                end_node_id=called_func.id,
                                type="CALLS",
                                properties={
                                    "file": caller_node.properties.get("file_path", ""),
                                    "line_number": line_num,
                                    "call_type": "function_call",
                                    "post_processed": True
                                }
                            )
                        )
                        logger.debug(f"Added cross-file function call: {caller_node.properties.get('name')} -> {func_name} at line {line_num}")

    @classmethod
    def reset_global_registry(cls):
        """Reset the global registry. Useful for testing or when processing new sets of files."""
        global _global_registry
        _global_registry = GlobalMatlabRegistry()
        logger.info("Global MATLAB registry reset")

    def _reset_state(self) -> None:
        """Reset the internal state for processing a new chunk."""
        self.nodes = []
        self.edges = []
        self.known_function_names: Set[str] = set()
        self.script_level_vars: Set[str] = set()
        self.function_parameters: Dict[str, List[str]] = defaultdict(list)
        self.variable_occurrences: Dict[str, List[Tuple[int, str]]] = defaultdict(list)
        self.variable_dependencies: Dict[str, Set[str]] = defaultdict(set)
        self.script_calls: Set[Tuple[str, str]] = set()
        self.current_function: Optional[str] = None
        self.text: str = ""
        self.path: str = ""
        self.lines: List[str] = []

        # Debug and optimization flags
        self.function_calls = set()  # Track function calls for deduplication
        self.processed_nodes = set()  # Track processed nodes for deduplication
        self.call_sites = {}  # Track call sites for better debugging
        self.variable_assignments = set()  # Track variable assignments
        self._line_offsets = None  # Cache for line number calculations

        # Track variable definitions and modifications
        self.variable_definitions = {}  # var_name -> (node_id, scope_type, scope_id)
        self.variable_scopes = []  # Stack of (scope_type, scope_id) for nested scopes
        self.current_scope = None  # Current scope (function/script) ID
        self.func_call_pattern = r'(?<![\w.])([a-zA-Z_]\w*)\s*(?=\()'

        # Track variable definitions within the current file scope
        self.defined_vars_in_current_file: Set[str] = set()

    def _create_uses_relationship_if_external(self, parent_id: str, var_name: str, var_id: str):
        """Creates a USES relationship for external variables with proper scope handling."""
        # Check if this variable is defined in a different scope
        # For now, we'll create the USES relationship for all external variable usage
        # The actual scope checking will be done during post-processing
        if self.debug:
            print(f"[DEBUG] Creating USES for '{var_name}' from '{parent_id}' to '{var_id}'")
        self._add_edge(parent_id, var_id, "USES", properties={
            "usage_type": "external_variable",
            "variable_name": var_name
        })

    def _process_variables_in_code(self, code: str, parent_id: str, file_path: str, line_offset: int = 0) -> None:
        lines = code.splitlines()
        first_code_line_index = -1
        for i, line in enumerate(lines):
            if line.strip() and not line.strip().startswith('%'):
                first_code_line_index = i
                break
        if first_code_line_index == -1:
            return
        code = '\n'.join(lines[first_code_line_index:])
        code = re.sub(r'%.*$', '', code, flags=re.MULTILINE)
        code = re.sub(r'%\{.*?%\}', '', code, flags=re.DOTALL)
        code = re.sub(r"'(?:''|[^'])*'", "''", code)
        code = re.sub(r'"(?:""|[^"])*"', '""', code)
        assignment_pattern = r'^\s*([a-zA-Z_]\w*)\s*=\s*(.+)'
        usage_pattern = r'\b([a-zA-Z_]\w*)\b'
        scope_vars = set()
        
        # 获取当前脚本名称用于注册
        script_name = os.path.basename(file_path)
        current_line = line_offset + 1
        
        for line in code.splitlines():
            current_line += 1
            match = re.match(assignment_pattern, line)
            if match:
                var_name = match.group(1)
                rhs = match.group(2)
                var_id = f"var_{var_name}_{parent_id}"
                if var_name not in scope_vars:
                    scope_vars.add(var_name)
                    if not self._node_exists(var_id):
                        var_node = {
                            "id": var_id,
                            "label": "Variable",
                            "name": var_name,
                            "file_path": file_path,
                            "scope_id": parent_id,
                            "scope_type": "function" if "func_" in parent_id else "script"
                        }
                        self._add_node_if_not_exists(var_node)
                    self._add_edge(parent_id, var_id, "DEFINES")
                    
                    # 注册变量定义到全局注册表
                    if "script_" in parent_id:
                        _global_registry.register_variable_definition(script_name, var_name, current_line)
                        
                else:
                    self._add_edge(parent_id, var_id, "MODIFIES")
                for rhs_var in re.findall(usage_pattern, rhs):
                    if rhs_var != var_name and rhs_var.lower() not in IDENTIFIERS_TO_EXCLUDE:
                        rhs_var_id = f"var_{rhs_var}_{parent_id}"
                        if not self._node_exists(rhs_var_id):
                            rhs_var_node = {
                                "id": rhs_var_id,
                                "label": "Variable",
                                "name": rhs_var,
                                "file_path": file_path,
                                "scope_id": parent_id,
                                "scope_type": "function" if "func_" in parent_id else "script"
                            }
                            self._add_node_if_not_exists(rhs_var_node)
                        self._add_edge(rhs_var_id, var_id, "ASSIGNED_TO")
            calls_in_line = set(m.group(1) for m in re.finditer(r'\b([a-zA-Z_]\w*)\s*\(', line))
            
            # 先检测脚本调用，避免被误认为是变量使用
            script_call_match = re.match(r'^\s*([a-zA-Z_]\w*)\s*;', line)
            if script_call_match:
                script_name = script_call_match.group(1)
                if self.debug:
                    print(f"[DEBUG] Found potential script call: '{script_name}' in line: '{line.strip()}'")
                if script_name.lower() not in IDENTIFIERS_TO_EXCLUDE:
                    found_script = False
                    for node in self.nodes:
                        if (node.get('label') == 'Script' and (node.get('name') == script_name or node.get('name') == script_name + '.m')):
                            self._add_edge(parent_id, node['id'], "CALLS", properties={
                                "call_type": "script_call",
                                "script_name": script_name
                            })
                            # 注册脚本依赖关系
                            current_script = os.path.basename(file_path)
                            _global_registry.register_script_dependency(current_script, script_name)
                            found_script = True
                            if self.debug:
                                print(f"[DEBUG] Created Script->Script CALLS from '{parent_id}' to script '{script_name}'")
                            break
                    if not found_script and self.debug:
                        print(f"[DEBUG] Script '{script_name}' not found in nodes. Available scripts: {[n.get('name') for n in self.nodes if n.get('label') == 'Script']}")
                    # 如果是脚本调用，跳过后续的变量使用检测
                    continue
            
            run_call_match = re.search(r"run\s*\(\s*['\"]([^'\"]+)['\"]\s*\)", line)
            if run_call_match:
                script_name = run_call_match.group(1)
                if self.debug:
                    print(f"[DEBUG] Found run() call: '{script_name}' in line: '{line.strip()}'")
                if script_name.lower() not in IDENTIFIERS_TO_EXCLUDE:
                    found_script = False
                    for node in self.nodes:
                        if (node.get('label') == 'Script' and (node.get('name') == script_name or node.get('name') == script_name.replace('.m', ''))):
                            self._add_edge(parent_id, node['id'], "CALLS", properties={
                                "call_type": "run_call",
                                "script_name": script_name
                            })
                            # 注册脚本依赖关系
                            current_script = os.path.basename(file_path)
                            _global_registry.register_script_dependency(current_script, script_name)
                            found_script = True
                            if self.debug:
                                print(f"[DEBUG] Created Script->Script CALLS from '{parent_id}' to script '{script_name}' via run()")
                            break
                    if not found_script and self.debug:
                        print(f"[DEBUG] Script '{script_name}' not found in nodes for run() call. Available scripts: {[n.get('name') for n in self.nodes if n.get('label') == 'Script']}")
                    # 如果是run()调用，跳过后续的变量使用检测
                    continue
            
            # 检测函数调用
            for func_call_match in re.finditer(r'\b([a-zA-Z_]\w*)\s*\([^)]*\)', line):
                func_name = func_call_match.group(1)
                if func_name.lower() not in IDENTIFIERS_TO_EXCLUDE:
                    for node in self.nodes:
                        if (node.get('label') == 'Function' and node.get('name') == func_name):
                            if parent_id.startswith('script_'):
                                self._add_edge(parent_id, node['id'], "CALLS", properties={
                                    "call_type": "function_call",
                                    "function_name": func_name
                                })
                                if self.debug:
                                    print(f"[DEBUG] Created Script->Function CALLS from '{parent_id}' to function '{func_name}'")
                            else:
                                self._add_edge(parent_id, node['id'], "CALLS", properties={
                                    "call_type": "function_call",
                                    "function_name": func_name
                                })
                                if self.debug:
                                    print(f"[DEBUG] Created CALLS from '{parent_id}' to function '{func_name}'")
                            break
            
            # 检测变量使用
            for match in re.finditer(usage_pattern, line):
                var_name = match.group(1)
                if var_name in calls_in_line:
                    continue
                if var_name.lower() in IDENTIFIERS_TO_EXCLUDE:
                    continue
                var_id = f"var_{var_name}_{parent_id}"
                if var_name not in scope_vars:
                    # 注册变量使用到全局注册表
                    if "script_" in parent_id:
                        _global_registry.register_variable_usage(script_name, var_name, current_line)
                    
                    # 检查是否是全局变量声明
                    if line.strip().startswith('global ') and var_name in line:
                        # 全局变量声明
                        if not self._node_exists(var_id):
                            var_node = {
                                "id": var_id,
                                "label": "Variable",
                                "name": var_name,
                                "file_path": file_path,
                                "scope_id": parent_id,
                                "scope_type": "function" if "func_" in parent_id else "script"
                            }
                            self._add_node_if_not_exists(var_node)
                        self._add_edge(parent_id, var_id, "DEFINES", properties={
                            "type": "global_variable"
                        })
                        if self.debug:
                            print(f"[DEBUG] Created global variable definition: {var_name} in {parent_id}")
                    else:
                        # 普通变量使用 - 在当前作用域内创建变量节点
                        if not self._node_exists(var_id):
                            var_node = {
                                "id": var_id,
                                "label": "Variable",
                                "name": var_name,
                                "file_path": file_path,
                                "scope_id": parent_id,
                                "scope_type": "function" if "func_" in parent_id else "script"
                            }
                            self._add_node_if_not_exists(var_node)
                        # 创建同作用域内的USES关系
                        self._add_edge(parent_id, var_id, "USES", properties={
                            "usage_type": "local_variable",
                            "variable_name": var_name
                        })
                        if self.debug:
                            print(f"[DEBUG] Created local USES for variable '{var_name}' from '{parent_id}' to '{var_id}'")

    def _parse_matlab_code(self) -> None:
        if not self.text.strip():
            return
        function_pattern = re.compile(
            r'^\s*function\s+(?:\[?([\w\s,]*)\]?\s*=\s*)?(\w+)\s*(?:\(([^)]*)\))?',
            re.MULTILINE
        )
        function_matches = list(function_pattern.finditer(self.text))
        script_name = os.path.basename(self.path)
        script_id = f"script_{script_name}"
        if not self._node_exists(script_id):
            script_node = {"id": script_id, "label": "Script", "name": script_name, "file_path": self.path}
            self._add_node_if_not_exists(script_node)
        # 先处理所有函数定义，确保 Function 节点已创建
        for match in function_matches:
            start_pos = match.start()
            end_pos = function_matches[function_matches.index(match)+1].start() if function_matches.index(match)+1 < len(function_matches) else len(self.text)
            func_code = self.text[start_pos:end_pos]
            original_text = self.text
            self.text = func_code
            try:
                self._parse_function()
            except Exception as e:
                print(f"Error parsing function at position {start_pos}: {str(e)}")
            finally:
                self.text = original_text
        # 再处理脚本体
        if function_matches:
            script_code = self.text[:function_matches[0].start()].strip()
            if script_code:
                self._process_variables_in_code(
                    script_code,
                    script_id,
                    self.path,
                    0
                )
        else:
            self._parse_script()
        self._extract_variables_and_relationships()

        # 后处理：建立跨作用域的 USES 关系
        self._establish_cross_scope_relationships()

    def _parse_function(self) -> None:
        func_match = re.search(
            r'^\s*function\s+(?:\[?([\w\s,]*)\]?\s*=\s*)?(\w+)\s*(?:\(([^)]*)\))?',
            self.text,
            re.MULTILINE
        )
        if not func_match:
            self._parse_script()
            return
        return_vars = [v.strip() for v in func_match.group(1).split(',')] if func_match.group(1) else []
        func_name = func_match.group(2)
        params = [p.strip() for p in func_match.group(3).split(',')] if func_match.group(3) else []
        if self.debug:
            print(f"[DEBUG] Parsed function parameters for '{func_name}': {params}")
        start_line = self.text.count('\n', 0, func_match.start()) + 1
        end_line = self.text.count('\n') + 1
        func_code = self._get_function_code_snippet(func_match)
        func_id = f"func_{func_name}_{len(self.nodes)}"
        script_name = os.path.basename(self.path)
        script_id = f"script_{script_name}"
        if not self._node_exists(script_id):
            script_node = {"id": script_id, "label": "Script", "name": script_name, "file_path": self.path}
            self._add_node_if_not_exists(script_node)
        self._add_edge(script_id, func_id, "DEFINES")
        self.function_parameters[func_id] = params
        self._add_node_if_not_exists({
            "id": func_id,
            "label": "Function",
            "name": func_name,
            "file_path": self.path,
            "line_range": [
                (func_code.split('\n')[0].strip(), f"{start_line}-{end_line}")
            ],
            "parameters": params,
            "returns": return_vars,
            "description": ""
        })
        prev_scope = self.current_scope
        self.current_scope = func_id
        self.variable_scopes.append(('function', func_id))
        try:
            for param in params:
                if self.debug:
                    print(f"[DEBUG] Processing parameter: '{param}' for function '{func_id}'")
                if not param or param.lower() in MATLAB_KEYWORDS:
                    if self.debug:
                        print(f"[DEBUG] Skipping parameter '{param}' due to exclusion check")
                        if param.lower() in MATLAB_KEYWORDS:
                            print(f"[DEBUG] '{param}' is in MATLAB_KEYWORDS")
                        if param.lower() in MATLAB_BUILTINS:
                            print(f"[DEBUG] '{param}' is in MATLAB_BUILTINS")
                        if param.lower() in COMMON_WORDS_TO_IGNORE:
                            print(f"[DEBUG] '{param}' is in COMMON_WORDS_TO_IGNORE")
                    continue
                param_key = (param, func_id)
                param_var_id = f"var_{param}_{func_id}"
                self.defined_vars_in_current_file.add(param_key)
                self.variable_definitions[param_key] = (param_var_id, 'Function', func_id)
                # 确保参数节点有正确的 scope_id 属性
                if not self._node_exists(param_var_id):
                    self._add_node_if_not_exists({
                        "id": param_var_id,
                        "label": "Variable",
                        "name": param,
                        "file_path": self.path,
                        "scope_id": func_id,  # 确保 scope_id 是 func_id
                        "scope_type": "function"
                    })
                    if self.debug:
                        print(f"[DEBUG] Created parameter variable node: {param_var_id} for param '{param}' in function '{func_id}'")
                # 添加 DEFINES 关系从函数到参数
                self._add_edge(
                    source_id=func_id,
                    target_id=param_var_id,
                    label="DEFINES",
                    properties={
                        "file": self.path,
                        "line": start_line,
                        "type": "parameter_definition"
                    }
                )
                if self.debug:
                    print(f"  [+] Defined parameter: {param} in {func_id}")
            self.current_function = func_id
            self.known_function_names.add(func_name)
            self._process_variables_in_code(
                func_code,
                func_id,
                self.path,
                start_line - 1
            )
        finally:
            self.current_scope = prev_scope
            if self.variable_scopes and self.variable_scopes[-1][1] == func_id:
                self.variable_scopes.pop()

    def _get_function_code_snippet(self, func_match) -> str:
        """Extract the full function code snippet."""
        start = func_match.start()
        brace_count = 0
        in_string = False
        string_char = None

        for i, char in enumerate(self.text[start:], start=start):
            # Handle string literals to avoid counting braces inside strings
            if char in ('"', "'"):
                if not in_string:
                    in_string = True
                    string_char = char
                elif char == string_char:
                    # Check if this is an escaped quote
                    if i > 0 and self.text[i-1] == '\\':
                        continue
                    in_string = False
                continue

            if in_string:
                continue

            # Count braces to find matching end
            if char == '{':
                brace_count += 1
            elif char == '}':
                brace_count -= 1
                if brace_count == 0:
                    return self.text[start:i+1].strip()

        # If we get here, return the rest of the text
        return self.text[start:].strip()

    def _parse_script(self) -> None:
        """Parse a MATLAB script file."""
        script_name = os.path.basename(self.path)
        if not script_name.endswith('.m'):
            return

        # Add script node
        script_id = f"script_{script_name}"

        # Get line range and code snippet (first 20 lines or all if less)
        code_lines = self.text.splitlines()
        end_line = min(20, len(code_lines))
        code_snippet = '\n'.join(code_lines[:end_line])
        line_range = (code_snippet, 1, end_line)

        # Add script node to the graph
        self._add_node_if_not_exists({
            "id": script_id,
            "label": "Script",
            "name": script_name,
            "file_path": self.path,
            "description": "",  # Will be filled by LLM later
            "line_range": line_range
        })

        # Set up script scope
        prev_scope = self.current_scope
        self.current_scope = script_id
        self.variable_scopes.append(('script', script_id))

        try:
            # Process variables in the script
            self._process_variables_in_code(
                self.text,
                script_id,
                self.path,
                0  # Line offset is 0 for scripts
            )

        finally:
            # Restore previous scope
            self.current_scope = prev_scope
            if self.variable_scopes and self.variable_scopes[-1][1] == script_id:
                self.variable_scopes.pop()

    def _get_line_number(self, text: str, offset: int = 0) -> int:
        """Get the 1-based line number for the given character offset.

        Args:
            text: The text to search in (unused, kept for backward compatibility)
            offset: Character offset to start searching from

        Returns:
            int: 1-based line number, or -1 if not found
        """
        # Initialize line offsets if not already done
        if self._line_offsets is None:
            self._line_offsets = [0]  # Line 1 starts at position 0
            for i, c in enumerate(self.text):
                if c == '\n':
                    self._line_offsets.append(i + 1)  # Next line starts after newline

        # Handle case where offset is out of range
        if offset < 0 or offset >= len(self.text):
            return -1

        # Find the line number for the given offset using binary search
        left, right = 0, len(self._line_offsets)
        while left < right:
            mid = (left + right) // 2
            if self._line_offsets[mid] > offset:
                right = mid
            else:
                left = mid + 1

        # Line numbers are 1-based, so return left as is (since we did left = mid + 1)
        return left

    def _add_edge(self, source_id: str, target_id: str, label: str, properties: dict = None, line_number: int = None) -> None:
        """Add an edge to the graph if it doesn't already exist with the same source, target, and label."""
        if not source_id or not target_id:
            return
        if properties is None:
            properties = {}
        if line_number is not None:
            properties['line_number'] = line_number
        prop_line = properties.get('line_number')
        for edge in self.edges:
            if (edge['source'] == source_id and edge['target'] == target_id and edge['label'] == label and edge['properties'].get('line_number') == prop_line):
                edge['properties'].update(properties)
                return
        self.edges.append({
            'source': source_id,
            'target': target_id,
            'label': label,
            'properties': properties or {}
        })

    async def _generate_descriptions(self) -> None:
        """Generate descriptions for functions and scripts using LLM."""
        for node in self.nodes:
            if node['label'] in ['Function', 'Script']:
                try:
                    # Generate a description using the LLM
                    prompt = f"Generate a brief description for this {node['label'].lower()}:"
                    if node['label'] == 'Function':
                        prompt += f"\nFunction: {node['name']}"
                        if node.get('parameters'):
                            prompt += f"\nParameters: {node['parameters']}"
                        if node.get('returns'):
                            prompt += f"\nReturns: {node['returns']}"
                    else:  # Script
                        prompt += f"\nScript: {node['name']}"

                    # Add context from the code
                    prompt += f"\n\nCode:\n{self.text}"

                    # Get description from LLM
                    description = await self.llm.generate(prompt)
                    node['description'] = description.strip()

                except Exception as e:
                    logger.warning(f"Failed to generate description for {node['name']}: {str(e)}")
                    node['description'] = "Description not available"

    def _get_code_snippet(self, node: Dict[str, Any]) -> str:
        """Get the code snippet for a node."""
        if node["type"] == "Function":
            # Extract function code
            func_name = node["name"]
            func_match = re.search(
                rf'^\s*function\s+(?:\[?[\w\s,]*\]?\s*=\s*)?{re.escape(func_name)}\s*\([^)]*\)[^{{]*{{?',
                self.text,
                re.MULTILINE
            )
            if func_match:
                start = func_match.start()
                # Find the matching end
                brace_count = 0
                for i, char in enumerate(self.text[start:], start=start):
                    if char == '{':
                        brace_count += 1
                    elif char == '}':
                        brace_count -= 1
                        if brace_count == 0:
                            return self.text[start:i+1]

        # Default to first 20 lines for scripts or if function parsing fails
        return '\n'.join(self.lines[:20])

    async def _generate_node_description(self, node: Dict[str, Any], code_snippet: str) -> str:
        """Generate a description for a node using the LLM."""
        prompt = f"""
        Analyze the following MATLAB {node["type"].lower()} and generate a concise description:

        {code_snippet}

        Description:
        """

        try:
            response = await self.llm.generate(prompt)
            return response.strip()
        except Exception as e:
            if self.on_error == OnError.RAISE:
                raise
            logger.warning(f"Failed to generate description for {node['name']}: {str(e)}")
            return ""

    async def run(
        self,
        chunks: TextChunks,
        document_info: Optional[Any] = None,
        lexical_graph_config: Optional[Any] = None,
        schema: Optional[GraphSchema] = None,
        examples: str = "",
        enable_post_processing: Optional[bool] = None,
        rebuild_data: bool = False,  # 新增：是否重新构建数据
        **kwargs: Any,
    ) -> MatlabExtractionResult:
        """Run the extraction pipeline with MATLAB-specific processing.

        Args:
            chunks: Text chunks to process
            document_info: Document information
            lexical_graph_config: Lexical graph configuration
            schema: Graph schema
            examples: Example text
            enable_post_processing: Override post-processing setting
            rebuild_data: Whether to rebuild all data or only update post-processing
            **kwargs: Additional arguments

        Returns:
            MatlabExtractionResult: The result containing the extracted graph.
        """
        # Override post-processing setting if provided
        if enable_post_processing is not None:
            self.enable_post_processing = enable_post_processing

        # 检查是否需要重新构建数据
        if not rebuild_data and _global_registry.all_nodes:
            # 如果不需要重新构建数据且已有数据，只进行后处理
            logger.info("Using existing data, only updating post-processing...")
            
            # 获取现有的图
            existing_nodes = []
            existing_relationships = []
            
            # 从全局注册表重建节点
            for node_data in _global_registry.all_nodes:
                try:
                    node = Neo4jNode(
                        id=node_data.get('id', ''),
                        label=node_data.get('label', ''),
                        properties=node_data.get('properties', {})
                    )
                    existing_nodes.append(node)
                except Exception as e:
                    logger.warning(f"Error creating node from existing data: {e}")
            
            # 从全局注册表重建关系
            for edge_data in _global_registry.all_edges:
                try:
                    rel = Neo4jRelationship(
                        start_node_id=edge_data.get('source', ''),
                        end_node_id=edge_data.get('target', ''),
                        type=edge_data.get('label', ''),
                        properties=edge_data.get('properties', {})
                    )
                    existing_relationships.append(rel)
                except Exception as e:
                    logger.warning(f"Error creating relationship from existing data: {e}")
            
            result = Neo4jGraph(nodes=existing_nodes, relationships=existing_relationships)
            
            # 应用后处理
            if self.enable_post_processing:
                logger.info("Applying post-processing for cross-file relationships...")
                result = self.post_process_cross_file_relationships(result)
            
            return MatlabExtractionResult(graph=result)

        # 确保有schema
        schema = schema or GraphSchema(node_types=[])

# 如果使用LLM，调用父类方法；否则使用纯Python实现
        if self.use_llm:
            # 运行父类的run方法
            result = await super().run(
                chunks=chunks,
                document_info=document_info,
                lexical_graph_config=lexical_graph_config,
                schema=schema,
                examples=examples,
                **kwargs,
            )
        else:
            # 使用纯Python实现
            logger.info("Using pure Python implementation for MATLAB code extraction")
            
            # 处理每个chunk
            chunk_graphs = []
            for chunk in chunks.chunks:
                chunk_graph = await self.extract_for_chunk(schema, examples, chunk)
                chunk_graphs.append(chunk_graph)
            
            # 合并所有chunk的结果
            result = Neo4jGraph()
            for chunk_graph in chunk_graphs:
                result.nodes.extend(chunk_graph.nodes)
                result.relationships.extend(chunk_graph.relationships)
            
            # 应用后处理
            if self.enable_post_processing:
                logger.info("Applying post-processing for cross-file relationships...")
                result = self.post_process_cross_file_relationships(result)        # 运行父类的run方法
# 如果使用LLM，调用父类方法；否则使用纯Python实现
        if self.use_llm:
            # 运行父类的run方法
            result = await super().run(
                chunks=chunks,
                document_info=document_info,
                lexical_graph_config=lexical_graph_config,
                schema=schema,
                examples=examples,
                **kwargs,
            )
        else:
            # 使用纯Python实现
            logger.info("Using pure Python implementation for MATLAB code extraction")
            
            # 处理每个chunk
            chunk_graphs = []
            for chunk in chunks.chunks:
                chunk_graph = await self.extract_for_chunk(schema, examples, chunk)
                chunk_graphs.append(chunk_graph)
            
            # 合并所有chunk的结果
            result = Neo4jGraph()
            for chunk_graph in chunk_graphs:
                result.nodes.extend(chunk_graph.nodes)
                result.relationships.extend(chunk_graph.relationships)
            
            # 应用后处理
            if self.enable_post_processing:
                logger.info("Applying post-processing for cross-file relationships...")
                result = self.post_process_cross_file_relationships(result)        result = await super().run(
# 如果使用LLM，调用父类方法；否则使用纯Python实现
        if self.use_llm:
            # 运行父类的run方法
            result = await super().run(
                chunks=chunks,
                document_info=document_info,
                lexical_graph_config=lexical_graph_config,
                schema=schema,
                examples=examples,
                **kwargs,
            )
        else:
            # 使用纯Python实现
            logger.info("Using pure Python implementation for MATLAB code extraction")
            
            # 处理每个chunk
            chunk_graphs = []
            for chunk in chunks.chunks:
                chunk_graph = await self.extract_for_chunk(schema, examples, chunk)
                chunk_graphs.append(chunk_graph)
            
            # 合并所有chunk的结果
            result = Neo4jGraph()
            for chunk_graph in chunk_graphs:
                result.nodes.extend(chunk_graph.nodes)
                result.relationships.extend(chunk_graph.relationships)
            
            # 应用后处理
            if self.enable_post_processing:
                logger.info("Applying post-processing for cross-file relationships...")
                result = self.post_process_cross_file_relationships(result)            chunks=chunks,
# 如果使用LLM，调用父类方法；否则使用纯Python实现
        if self.use_llm:
            # 运行父类的run方法
            result = await super().run(
                chunks=chunks,
                document_info=document_info,
                lexical_graph_config=lexical_graph_config,
                schema=schema,
                examples=examples,
                **kwargs,
            )
        else:
            # 使用纯Python实现
            logger.info("Using pure Python implementation for MATLAB code extraction")
            
            # 处理每个chunk
            chunk_graphs = []
            for chunk in chunks.chunks:
                chunk_graph = await self.extract_for_chunk(schema, examples, chunk)
                chunk_graphs.append(chunk_graph)
            
            # 合并所有chunk的结果
            result = Neo4jGraph()
            for chunk_graph in chunk_graphs:
                result.nodes.extend(chunk_graph.nodes)
                result.relationships.extend(chunk_graph.relationships)
            
            # 应用后处理
            if self.enable_post_processing:
                logger.info("Applying post-processing for cross-file relationships...")
                result = self.post_process_cross_file_relationships(result)            document_info=document_info,
# 如果使用LLM，调用父类方法；否则使用纯Python实现
        if self.use_llm:
            # 运行父类的run方法
            result = await super().run(
                chunks=chunks,
                document_info=document_info,
                lexical_graph_config=lexical_graph_config,
                schema=schema,
                examples=examples,
                **kwargs,
            )
        else:
            # 使用纯Python实现
            logger.info("Using pure Python implementation for MATLAB code extraction")
            
            # 处理每个chunk
            chunk_graphs = []
            for chunk in chunks.chunks:
                chunk_graph = await self.extract_for_chunk(schema, examples, chunk)
                chunk_graphs.append(chunk_graph)
            
            # 合并所有chunk的结果
            result = Neo4jGraph()
            for chunk_graph in chunk_graphs:
                result.nodes.extend(chunk_graph.nodes)
                result.relationships.extend(chunk_graph.relationships)
            
            # 应用后处理
            if self.enable_post_processing:
                logger.info("Applying post-processing for cross-file relationships...")
                result = self.post_process_cross_file_relationships(result)            lexical_graph_config=lexical_graph_config,
# 如果使用LLM，调用父类方法；否则使用纯Python实现
        if self.use_llm:
            # 运行父类的run方法
            result = await super().run(
                chunks=chunks,
                document_info=document_info,
                lexical_graph_config=lexical_graph_config,
                schema=schema,
                examples=examples,
                **kwargs,
            )
        else:
            # 使用纯Python实现
            logger.info("Using pure Python implementation for MATLAB code extraction")
            
            # 处理每个chunk
            chunk_graphs = []
            for chunk in chunks.chunks:
                chunk_graph = await self.extract_for_chunk(schema, examples, chunk)
                chunk_graphs.append(chunk_graph)
            
            # 合并所有chunk的结果
            result = Neo4jGraph()
            for chunk_graph in chunk_graphs:
                result.nodes.extend(chunk_graph.nodes)
                result.relationships.extend(chunk_graph.relationships)
            
            # 应用后处理
            if self.enable_post_processing:
                logger.info("Applying post-processing for cross-file relationships...")
                result = self.post_process_cross_file_relationships(result)            schema=schema,
# 如果使用LLM，调用父类方法；否则使用纯Python实现
        if self.use_llm:
            # 运行父类的run方法
            result = await super().run(
                chunks=chunks,
                document_info=document_info,
                lexical_graph_config=lexical_graph_config,
                schema=schema,
                examples=examples,
                **kwargs,
            )
        else:
            # 使用纯Python实现
            logger.info("Using pure Python implementation for MATLAB code extraction")
            
            # 处理每个chunk
            chunk_graphs = []
            for chunk in chunks.chunks:
                chunk_graph = await self.extract_for_chunk(schema, examples, chunk)
                chunk_graphs.append(chunk_graph)
            
            # 合并所有chunk的结果
            result = Neo4jGraph()
            for chunk_graph in chunk_graphs:
                result.nodes.extend(chunk_graph.nodes)
                result.relationships.extend(chunk_graph.relationships)
            
            # 应用后处理
            if self.enable_post_processing:
                logger.info("Applying post-processing for cross-file relationships...")
                result = self.post_process_cross_file_relationships(result)            examples=examples,
            **kwargs,
        )

        # 确保返回正确类型的结果
        if not isinstance(result, Neo4jGraph):
            if isinstance(result, dict):
                # 转换dict到Neo4jGraph
                nodes = result.get('nodes', [])
                relationships = result.get('relationships', [])
                result = Neo4jGraph(nodes=nodes, relationships=relationships)
            else:
                # 如果结果不是Neo4jGraph，转换它
                result = Neo4jGraph(
                    nodes=getattr(result, 'nodes', []),
                    relationships=getattr(result, 'relationships', [])
                )

        # 确保nodes和relationships是列表
        if not hasattr(result, 'nodes') or result.nodes is None:
            result.nodes = []
        if not hasattr(result, 'relationships') or result.relationships is None:
            result.relationships = []

        # 应用后处理（如果启用）
        if self.enable_post_processing:
            logger.info("Applying post-processing for cross-file relationships...")
            result = self.post_process_cross_file_relationships(result)

        # 包装在我们的自定义结果类型中
        return MatlabExtractionResult(graph=result)

    def _cleanup_duplicates(self) -> None:
        """Remove duplicate nodes and edges before creating the final graph."""
        if self.debug:
            original_node_count = len(self.nodes)
            original_edge_count = len(self.edges)
        # Remove duplicate nodes (keep first occurrence)
        seen_node_ids = set()
        unique_nodes = []
        for node in self.nodes:
            node_id = node.get('id')
            if node_id and node_id not in seen_node_ids:
                seen_node_ids.add(node_id)
                unique_nodes.append(node)
        self.nodes = unique_nodes
        # Remove duplicate edges (keep first occurrence of (source, target, label, line_number))
        seen_edges = set()
        unique_edges = []
        for edge in self.edges:
            edge_key = (edge.get('source'), edge.get('target'), edge.get('label'), edge.get('properties', {}).get('line_number'))
            if edge_key not in seen_edges:
                seen_edges.add(edge_key)
                unique_edges.append(edge)
        self.edges = unique_edges
        if self.debug:
            print(f"[DEBUG] Cleaned up duplicates: {original_node_count} -> {len(self.nodes)} nodes, {original_edge_count} -> {len(self.edges)} edges")

    def _extract_variables_and_relationships(self) -> None:
        """Extract variables and their relationships from the parsed code.
        This method processes the collected variable definitions, occurrences, and dependencies
        to create appropriate nodes and edges in the graph.
        """
        if self.debug:
            print("Extracting variables and relationships...")
            print(f"Found {len(self.variable_definitions)} variable definitions")

        # Process each variable definition
        for (var_name, scope_id), (var_id, scope_type, scope_id2) in self.variable_definitions.items():
            if var_name in IDENTIFIERS_TO_EXCLUDE:
                continue
            # Create variable node if it doesn't exist
            if not any(n.get('id') == var_id for n in self.nodes):
                self._add_node_if_not_exists({
                    'id': var_id,
                    'label': 'Variable',
                    'name': var_name,
                    'scope_type': scope_type.lower(),
                    'scope_id': scope_id,  # 确保 scope_id 在 properties 中
                    'file_path': self.path,
                })
            # Add DEFINES relationship from scope to variable
            if scope_type.lower() == 'function':
                self._add_edge(
                    source_id=scope_id,
                    target_id=var_id,
                    label='DEFINES',
                    properties={'type': 'parameter' if (var_name, scope_id) in self.variable_definitions else 'local'}
                )
            elif scope_type.lower() == 'script':
                self._add_edge(
                    source_id=scope_id,
                    target_id=var_id,
                    label='DEFINES',
                    properties={'type': 'variable_definition'}
                )
        # 变量依赖关系（如有）
        for (var_name, scope_id), deps in getattr(self, 'variable_dependencies', {}).items():
            if (var_name, scope_id) not in self.variable_definitions:
                continue
            var_id = self.variable_definitions[(var_name, scope_id)][0]
            for dep_var, dep_scope in deps:
                if (dep_var, dep_scope) in self.variable_definitions and dep_var not in IDENTIFIERS_TO_EXCLUDE:
                    dep_id = self.variable_definitions[(dep_var, dep_scope)][0]
                    self._add_edge(
                        source_id=var_id,
                        target_id=dep_id,
                        label='USES',
                        properties={'type': 'dependency'}
                    )
        if self.debug:
            print(f"Extracted {len(self.nodes)} nodes and {len(self.edges)} edges")

    def _establish_cross_scope_relationships(self) -> None:
        """Establish cross-scope USES relationships after all nodes are created."""
        if self.debug:
            print("[DEBUG] Establishing cross-scope relationships...")

        # 获取当前文件中的所有变量节点
        current_file_vars = []
        for node in self.nodes:
            if (node.get('label') == 'Variable' and
                node.get('file_path') == self.path):
                current_file_vars.append(node)

        # 获取全局注册表中的所有变量节点
        all_vars = []
        for node in _global_registry.all_nodes:
            if node.get('label') == 'Variable':
                all_vars.append(node)

        # 为当前文件中的每个变量使用查找跨作用域的定义
        for current_var in current_file_vars:
            var_name = current_var.get('name')
            current_scope = current_var.get('scope_id')

            # 查找其他作用域中同名的变量
            for other_var in all_vars:
                if (other_var.get('name') == var_name and
                    other_var.get('scope_id') != current_scope and
                    other_var.get('file_path') != self.path):  # 确保是不同文件

                    # 检查是否已经存在这个关系
                    existing_edge = next(
                        (edge for edge in self.edges
                         if (edge['source'] == current_scope and
                             edge['target'] == other_var['id'] and
                             edge['label'] == 'USES')),
                        None
                    )

                    if not existing_edge:
                        self._add_edge(current_scope, other_var['id'], "USES", properties={
                            "usage_type": "cross_scope",
                            "variable_name": var_name,
                            "from_scope": current_scope,
                            "to_scope": other_var.get('scope_id'),
                            "cross_file": True
                        })
                        if self.debug:
                            print(f"[DEBUG] Created cross-file cross-scope USES: {current_scope} -> {other_var['id']} ({var_name})")

        # 建立 Script -> Script CALLS 关系
        self._establish_script_to_script_calls()

    def _establish_script_to_script_calls(self) -> None:
        """Establish Script -> Script CALLS relationships."""
        if self.debug:
            print("[DEBUG] Establishing Script -> Script CALLS relationships...")

        # 获取当前文件中的所有脚本节点
        current_scripts = []
        for node in self.nodes:
            if (node.get('label') == 'Script' and
                node.get('file_path') == self.path):
                current_scripts.append(node)

        # 获取全局注册表中的所有脚本节点
        all_scripts = []
        for node in _global_registry.all_nodes:
            if node.get('label') == 'Script':
                all_scripts.append(node)

        # 检查当前文件中的脚本调用
        for current_script in current_scripts:
            script_name = current_script.get('name')
            current_script_id = current_script.get('id')

            # 查找被调用的脚本
            for other_script in all_scripts:
                other_script_name = other_script.get('name')
                if (other_script_name != script_name and
                    other_script.get('file_path') != self.path):

                    # 检查是否已经存在这个关系
                    existing_edge = next(
                        (edge for edge in self.edges
                         if (edge['source'] == current_script_id and
                             edge['target'] == other_script['id'] and
                             edge['label'] == 'CALLS')),
                        None
                    )

                    if not existing_edge:
                        # 检查是否在当前文件中调用了其他脚本
                        if self._script_calls_other_script(script_name, other_script_name):
                            self._add_edge(current_script_id, other_script['id'], "CALLS", properties={
                                "call_type": "script_call",
                                "script_name": other_script_name,
                                "cross_file": True
                            })
                            if self.debug:
                                print(f"[DEBUG] Created Script -> Script CALLS: {current_script_id} -> {other_script['id']} ({other_script_name})")

    def _script_calls_other_script(self, caller_name: str, callee_name: str) -> bool:
        """Check if a script calls another script."""
        # 检查直接调用 (script_name;)
        if f"{callee_name};" in self.text:
            return True

        # 检查 run('script_name.m') 调用
        if f"run('{callee_name}.m')" in self.text or f'run("{callee_name}.m")' in self.text:
            return True

        # 检查 run('script_name') 调用（不带 .m）
        if f"run('{callee_name}')" in self.text or f'run("{callee_name}")' in self.text:
            return True

        return False
