#!/usr/bin/env python3
"""
测试跨作用域关系处理的脚本

这个脚本用于验证：
1. 解析阶段只生成同作用域内的USES和ASSIGNED_TO关系
2. 后处理阶段才生成跨作用域的USES和ASSIGNED_TO关系
"""

import asyncio
import sys
import os
from pathlib import Path

# 添加项目根目录到Python路径
project_root = Path(__file__).parent
sys.path.insert(0, str(project_root))

from neo4j_graphrag.experimental.components.code_extractor.matlab.matlab_extractor import (
    MatlabExtractor, get_global_registry
)
from neo4j_graphrag.experimental.components.code_extractor.matlab.requirements import SCHEMA, EXAMPLES
from neo4j_graphrag.experimental.components.code_extractor.matlab.post_processor import MatlabPostProcessor
from neo4j_graphrag.experimental.components.types import TextChunk, TextChunks, DocumentInfo, LexicalGraphConfig

class MockLLM:
    """Mock LLM for testing purposes."""
    async def generate(self, prompt: str) -> str:
        return "Mock description generated by LLM"

async def test_cross_scope_relationships():
    """测试跨作用域关系处理"""
    print("=== 测试跨作用域关系处理 ===")

    # 创建测试MATLAB代码 - 包含跨作用域变量使用
    main_script_code = """% main_script.m
% 定义变量
x = 10;
y = x + 5;
z = y * 2;

% 调用其他脚本
helper_script;

% 调用函数
result = helper_function(x);

% 使用来自helper_script的变量
final_result = config + result;
"""

    helper_script_code = """% helper_script.m
% 定义变量
config = 100;
temp_var = 50;
shared_data = 200;
"""

    helper_function_code = """function result = helper_function(input_val)
    % 函数内部变量
    local_var = input_val * 2;
    result = local_var + 10;

    % 使用外部变量（跨作用域）
    global_var = shared_data;
end
"""

    # 创建临时文件
    test_dir = Path("test_matlab_files")
    test_dir.mkdir(exist_ok=True)

    # 使用UTF-8编码写入文件
    (test_dir / "main_script.m").write_text(main_script_code, encoding='utf-8')
    (test_dir / "helper_script.m").write_text(helper_script_code, encoding='utf-8')
    (test_dir / "helper_function.m").write_text(helper_function_code, encoding='utf-8')

    try:
        # 初始化提取器
        llm = MockLLM()
        extractor = MatlabExtractor(
            llm=llm,
            entry_script_path=str(test_dir / "main_script.m"),
            enable_post_processing=False  # 禁用后处理
        )

        print("\n1. 解析阶段 - 只生成同作用域关系")

        # 处理所有文件，但不进行后处理
        all_nodes = []
        all_relationships = []

        for file_path in [test_dir / "main_script.m", test_dir / "helper_script.m", test_dir / "helper_function.m"]:
            chunk = TextChunk(
                text=file_path.read_text(encoding='utf-8'),
                index=0,
                metadata={"file_path": str(file_path), "file_name": file_path.name, "code_type": "matlab"}
            )

            doc_info = DocumentInfo(
                path=str(file_path),
                metadata={"name": file_path.name}
            )

            # 只进行解析，不进行后处理
            result = await extractor.run(
                chunks=TextChunks(chunks=[chunk]),
                schema=SCHEMA,
                document_info=doc_info,
                lexical_graph_config=LexicalGraphConfig(),
                examples=EXAMPLES,
                enable_post_processing=False,
            )

            if result and hasattr(result, 'graph') and result.graph:
                all_nodes.extend(result.graph.nodes)
                all_relationships.extend(result.graph.relationships)

        print(f"解析阶段生成的节点数: {len(all_nodes)}")
        print(f"解析阶段生成的关系数: {len(all_relationships)}")

        # 分析解析阶段的关系类型
        print("\n解析阶段的关系类型:")
        rel_types = {}
        for rel in all_relationships:
            rel_type = rel.type
            if rel_type not in rel_types:
                rel_types[rel_type] = []
            rel_types[rel_type].append({
                'source': rel.start_node_id,
                'target': rel.end_node_id,
                'properties': rel.properties
            })

        for rel_type, rels in rel_types.items():
            print(f"  {rel_type}: {len(rels)} 个关系")
            for rel in rels[:3]:  # 显示前3个
                print(f"    {rel['source']} -> {rel['target']}")
                if 'post_processed' in rel['properties']:
                    print(f"      (post_processed: {rel['properties']['post_processed']})")

        # 检查是否有跨作用域关系
        cross_scope_rels = [rel for rel in all_relationships
                           if rel.properties.get('post_processed', False)]
        print(f"\n解析阶段中的跨作用域关系数: {len(cross_scope_rels)}")

        if cross_scope_rels:
            print("❌ 警告：解析阶段不应该有跨作用域关系！")
            for rel in cross_scope_rels:
                print(f"  发现跨作用域关系: {rel.start_node_id} -[{rel.type}]-> {rel.end_node_id}")
        else:
            print("✓ 解析阶段正确：没有跨作用域关系")

        # 详细分析USES关系
        uses_rels = [rel for rel in all_relationships if rel.type == 'USES']
        print(f"\n解析阶段的USES关系详情:")
        for rel in uses_rels:
            source_scope = rel.start_node_id.split('_')[2] if '_' in rel.start_node_id else 'unknown'
            target_scope = rel.end_node_id.split('_')[2] if '_' in rel.end_node_id else 'unknown'
            print(f"  {rel.start_node_id} -[USES]-> {rel.end_node_id}")
            print(f"    作用域: {source_scope} -> {target_scope}")
            print(f"    属性: {rel.properties}")

        # 详细分析ASSIGNED_TO关系
        assigned_rels = [rel for rel in all_relationships if rel.type == 'ASSIGNED_TO']
        print(f"\n解析阶段的ASSIGNED_TO关系详情:")
        for rel in assigned_rels:
            source_scope = rel.start_node_id.split('_')[2] if '_' in rel.start_node_id else 'unknown'
            target_scope = rel.end_node_id.split('_')[2] if '_' in rel.end_node_id else 'unknown'
            print(f"  {rel.start_node_id} -[ASSIGNED_TO]-> {rel.end_node_id}")
            print(f"    作用域: {source_scope} -> {target_scope}")
            print(f"    属性: {rel.properties}")

        print("\n2. 后处理阶段 - 生成跨作用域关系")

        # 创建临时图进行后处理
        from neo4j_graphrag.experimental.components.types import Neo4jGraph
        temp_graph = Neo4jGraph(nodes=all_nodes, relationships=all_relationships)

        # 应用后处理
        post_processor = MatlabPostProcessor()
        final_graph = post_processor.post_process_cross_file_relationships(temp_graph)

        print(f"后处理后生成的节点数: {len(final_graph.nodes)}")
        print(f"后处理后生成的关系数: {len(final_graph.relationships)}")

        # 检查跨作用域关系
        cross_scope_rels_after = [rel for rel in final_graph.relationships
                                 if rel.properties.get('post_processed', False)]
        print(f"\n后处理后的跨作用域关系数: {len(cross_scope_rels_after)}")

        if cross_scope_rels_after:
            print("✓ 后处理阶段正确：生成了跨作用域关系")
            for rel in cross_scope_rels_after:
                print(f"  跨作用域关系: {rel.start_node_id} -[{rel.type}]-> {rel.end_node_id}")
                print(f"    属性: {rel.properties}")
        else:
            print("❌ 警告：后处理阶段应该生成跨作用域关系！")

        # 验证关系模式
        print("\n3. 验证关系模式")

        # 检查USES关系
        uses_rels = [rel for rel in final_graph.relationships if rel.type == 'USES']
        local_uses = [rel for rel in uses_rels if not rel.properties.get('post_processed', False)]
        cross_uses = [rel for rel in uses_rels if rel.properties.get('post_processed', False)]

        print(f"USES关系总数: {len(uses_rels)}")
        print(f"  同作用域USES: {len(local_uses)}")
        print(f"  跨作用域USES: {len(cross_uses)}")

        # 检查ASSIGNED_TO关系
        assigned_rels = [rel for rel in final_graph.relationships if rel.type == 'ASSIGNED_TO']
        local_assigned = [rel for rel in assigned_rels if not rel.properties.get('post_processed', False)]
        cross_assigned = [rel for rel in assigned_rels if rel.properties.get('post_processed', False)]

        print(f"ASSIGNED_TO关系总数: {len(assigned_rels)}")
        print(f"  同作用域ASSIGNED_TO: {len(local_assigned)}")
        print(f"  跨作用域ASSIGNED_TO: {len(cross_assigned)}")

        # 验证SCHEMA要求
        print("\n4. 验证SCHEMA要求")

        # 检查变量节点是否按作用域分离
        var_nodes = [node for node in final_graph.nodes if node.label == 'Variable']
        var_by_name = {}
        for node in var_nodes:
            var_name = node.properties.get('name', '')
            if var_name not in var_by_name:
                var_by_name[var_name] = []
            var_by_name[var_name].append(node)

        print(f"变量节点总数: {len(var_nodes)}")
        for var_name, nodes in var_by_name.items():
            if len(nodes) > 1:
                print(f"  变量 '{var_name}' 在 {len(nodes)} 个作用域中:")
                for node in nodes:
                    scope_id = node.properties.get('scope_id', 'unknown')
                    scope_type = node.properties.get('scope_type', 'unknown')
                    print(f"    - {scope_type}: {scope_id}")
            else:
                print(f"  变量 '{var_name}' 在 1 个作用域中")

        print("\n=== 测试完成 ===")

    finally:
        # 清理临时文件
        import shutil
        if test_dir.exists():
            shutil.rmtree(test_dir)

if __name__ == "__main__":
    asyncio.run(test_cross_scope_relationships())
