#!/usr/bin/env python3
"""
Comprehensive test suite for MATLAB code extractor with latest features.

This test suite covers:
1. Scope-specific variable handling (each script/function has its own variable nodes)
2. All relationship types: CALLS, USES, DEFINES, MODIFIES, ASSIGNED_TO
3. Cross-scope variable relationships
4. Function and script parsing
5. Variable assignment and modification tracking
"""

import os
import sys
import asyncio
import unittest
from pathlib import Path

# Add the project root to the path
sys.path.insert(0, str(Path(__file__).parent.parent.parent))

from unittest.mock import MagicMock
from typing import Dict, List, Set, Tuple, Any

from neo4j_graphrag.experimental.components.code_extractor.matlab.matlab_extractor import MatlabExtractor
from neo4j_graphrag.experimental.components.code_extractor.matlab.schema import SCHEMA
from neo4j_graphrag.experimental.components.types import TextChunk, TextChunks, DocumentInfo

class MockLLM:
    """Mock LLM for testing."""
    async def generate(self, prompt: str) -> str:
        return "Mock description generated by LLM"

class TestComprehensiveMatlabExtraction(unittest.TestCase):
    """Comprehensive test suite for MATLAB code extraction."""

    @classmethod
    def setUpClass(cls):
        """Set up the test environment."""
        cls.test_dir = Path(__file__).parent / "examples"
        cls.test_dir.mkdir(exist_ok=True)

        # Create comprehensive test files
        cls.create_test_files()

        # Set up extractor
        cls.mock_llm = MockLLM()
        cls.extractor = MatlabExtractor(
            llm=cls.mock_llm,
            enable_post_processing=True
        )

    @classmethod
    def create_test_files(cls):
        """Create comprehensive test MATLAB files."""

        # Test file 1: Main script with variables and function calls
        with open(cls.test_dir / "main_script.m", "w") as f:
            f.write("""
% Main script demonstrating comprehensive relationship patterns

% Define script-level variables
x = 10;
y = x + 5;
z = y * 2;

% Call functions
result1 = helper_function(x);
[modified_x, modified_y] = modify_variables(x, y);

% Call another script
run('helper_script.m');

% Use variables in calculations
final_result = modified_x + modified_y + z;

% Display results
display_results(final_result, result1);
""")

        # Test file 2: Helper function
        with open(cls.test_dir / "helper_function.m", "w") as f:
            f.write("""
function result = helper_function(input)
    % Helper function that processes input
    x = input * 2;  % Same variable name as main script
    y = x + 10;     % Same variable name as main script
    result = y;
end
""")

        # Test file 3: Variable modification function
        with open(cls.test_dir / "modify_variables.m", "w") as f:
            f.write("""
function [out1, out2] = modify_variables(in1, in2)
    % Function that modifies input variables
    out1 = in1 * 2;
    out2 = in2 + 10;

    % Internal variable with same name as inputs
    x = out1 + out2;
    y = x / 2;
end
""")

        # Test file 4: Helper script
        with open(cls.test_dir / "helper_script.m", "w") as f:
            f.write("""
% Helper script with its own variables

% Script-level variables
a = 42;
b = a / 2;
c = b + 10;

% Call a function
d = helper_function(c);

% Use variables
result = a + b + c + d;
""")

        # Test file 5: Display function
        with open(cls.test_dir / "display_results.m", "w") as f:
            f.write("""
function display_results(varargin)
    % Function that displays multiple results
    for i = 1:length(varargin)
        fprintf('Result %d: %f\\n', i, varargin{i});
    end
end
""")

    def setUp(self):
        """Set up before each test."""
        # Reset the global registry for clean tests
        MatlabExtractor.reset_global_registry()

    async def extract_file(self, file_path: Path) -> Tuple[List[Dict], List[Dict]]:
        """Extract nodes and relationships from a MATLAB file."""
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()

        chunk = TextChunk(
            text=content,
            index=0,
            metadata={"file_path": str(file_path)}
        )

        # Use predefined SCHEMA
        result = await self.extractor.extract_for_chunk(SCHEMA, "", chunk)
        
        if result and hasattr(result, 'nodes'):
            nodes = result.nodes
        else:
            nodes = []
            
        if result and hasattr(result, 'relationships'):
            relationships = result.relationships
        else:
            relationships = []
            
        return nodes, relationships

    def test_scope_specific_variables(self):
        """Test that variables are scope-specific with proper ID format."""
        print("\nTesting scope-specific variables...")
        
        async def run_test():
            # Extract from main script
            main_nodes, _ = await self.extract_file(self.test_dir / "main_script.m")
            
            # Extract from helper function
            func_nodes, _ = await self.extract_file(self.test_dir / "helper_function.m")
            
            # Find variable nodes
            main_vars = [node for node in main_nodes if node.get('type') == 'Variable']
            func_vars = [node for node in func_nodes if node.get('type') == 'Variable']
            
            # Check main script variables
            for var in main_vars:
                var_id = var.get('id', '')
                properties = var.get('properties', {})
                name = properties.get('name', '')
                scope_id = properties.get('scope_id', '')
                scope_type = properties.get('scope_type', '')
                
                # Check ID format
                expected_id = f"var_{name}_{scope_id}"
                assert var_id == expected_id, f"Variable ID format mismatch: {var_id} != {expected_id}"
                
                # Check scope properties
                assert scope_type == 'script', f"Main script variable should have scope_type 'script': {scope_type}"
                assert 'main_script' in scope_id, f"Main script variable should have main_script in scope_id: {scope_id}"
            
            # Check function variables
            for var in func_vars:
                var_id = var.get('id', '')
                properties = var.get('properties', {})
                name = properties.get('name', '')
                scope_id = properties.get('scope_id', '')
                scope_type = properties.get('scope_type', '')
                
                # Check ID format
                expected_id = f"var_{name}_{scope_id}"
                assert var_id == expected_id, f"Variable ID format mismatch: {var_id} != {expected_id}"
                
                # Check scope properties
                assert scope_type == 'function', f"Function variable should have scope_type 'function': {scope_type}"
                assert 'helper_function' in scope_id, f"Function variable should have helper_function in scope_id: {scope_id}"
            
            # Check that variables with same names have different IDs
            main_var_names = [var.get('properties', {}).get('name', '') for var in main_vars]
            func_var_names = [var.get('properties', {}).get('name', '') for var in func_vars]
            
            common_names = set(main_var_names) & set(func_var_names)
            for name in common_names:
                main_var = next(v for v in main_vars if v.get('properties', {}).get('name') == name)
                func_var = next(v for v in func_vars if v.get('properties', {}).get('name') == name)
                
                assert main_var.get('id') != func_var.get('id'), f"Variables with same name should have different IDs: {name}"
            
            print(f"✓ Scope-specific variables working correctly ({len(main_vars)} main script vars, {len(func_vars)} function vars)")
            return True
        
        return asyncio.run(run_test())

    def test_relationship_patterns(self):
        """Test that all required relationship patterns are created."""
        print("\nTesting relationship patterns...")
        
        async def run_test():
            # Extract from all files
            all_nodes = []
            all_relationships = []
            
            test_files = ["main_script.m", "helper_function.m", "modify_variables.m", "helper_script.m", "display_results.m"]
            
            for file_name in test_files:
                file_path = self.test_dir / file_name
                if file_path.exists():
                    nodes, relationships = await self.extract_file(file_path)
                    all_nodes.extend(nodes)
                    all_relationships.extend(relationships)
            
            # Check relationship types
            rel_types = set(rel.get('type') for rel in all_relationships)
            expected_types = {"CALLS", "USES", "DEFINES", "MODIFIES", "ASSIGNED_TO"}
            
            for rel_type in expected_types:
                assert rel_type in rel_types, f"Missing relationship type: {rel_type}"
            
            # Check specific patterns
            patterns_found = set()
            for rel in all_relationships:
                source_type = rel.get('source_type', '')
                rel_type = rel.get('type', '')
                target_type = rel.get('target_type', '')
                pattern = (source_type, rel_type, target_type)
                patterns_found.add(pattern)
            
            # Verify all required patterns are present
            required_patterns = [
                ("Script", "CALLS", "Function"),
                ("Script", "CALLS", "Script"),
                ("Function", "CALLS", "Function"),
                ("Script", "USES", "Variable"),
                ("Function", "USES", "Variable"),
                ("Script", "DEFINES", "Variable"),
                ("Function", "DEFINES", "Variable"),
                ("Script", "DEFINES", "Function"),
                ("Script", "MODIFIES", "Variable"),
                ("Function", "MODIFIES", "Variable"),
                ("Variable", "ASSIGNED_TO", "Variable"),
            ]
            
            for pattern in required_patterns:
                assert pattern in patterns_found, f"Missing required pattern: {pattern}"
            
            print(f"✓ All {len(required_patterns)} required relationship patterns found")
            return True
        
        return asyncio.run(run_test())

    def test_variable_assignment_tracking(self):
        """Test that variable assignments are properly tracked."""
        print("\nTesting variable assignment tracking...")
        
        async def run_test():
            # Extract from main script
            nodes, relationships = await self.extract_file(self.test_dir / "main_script.m")
            
            # Find ASSIGNED_TO relationships
            assigned_to_rels = [rel for rel in relationships if rel.get('type') == 'ASSIGNED_TO']
            
            # Should have assignments like y = x + 5, z = y * 2
            assert len(assigned_to_rels) >= 2, f"Expected at least 2 assignments, found {len(assigned_to_rels)}"
            
            for rel in assigned_to_rels:
                source_id = rel.get('source_id', '')
                target_id = rel.get('target_id', '')
                
                # Both should be variables
                assert 'var_' in source_id, f"ASSIGNED_TO source should be a variable: {source_id}"
                assert 'var_' in target_id, f"ASSIGNED_TO target should be a variable: {target_id}"
                
                # Should be in same scope
                source_scope = source_id.split('_', 2)[2] if '_' in source_id else ''
                target_scope = target_id.split('_', 2)[2] if '_' in target_id else ''
                assert source_scope == target_scope, f"Assignment should be within same scope: {source_scope} != {target_scope}"
            
            print(f"✓ Variable assignment tracking working correctly ({len(assigned_to_rels)} assignments)")
            return True
        
        return asyncio.run(run_test())

    def test_function_parameter_handling(self):
        """Test that function parameters are handled correctly."""
        print("\nTesting function parameter handling...")
        
        async def run_test():
            # Extract from modify_variables function
            nodes, relationships = await self.extract_file(self.test_dir / "modify_variables.m")
            
            # Find function node
            func_nodes = [node for node in nodes if node.get('type') == 'Function']
            assert len(func_nodes) == 1, "Should have exactly one function node"
            
            func_node = func_nodes[0]
            func_id = func_node.get('id', '')
            properties = func_node.get('properties', {})
            parameters = properties.get('parameters', '')
            
            # Check parameters
            expected_params = ['in1', 'in2']
            param_list = [p.strip() for p in parameters.split(',') if p.strip()]
            assert param_list == expected_params, f"Parameters mismatch: {param_list} != {expected_params}"
            
            # Check that parameters are defined as variables in function scope
            var_nodes = [node for node in nodes if node.get('type') == 'Variable']
            param_vars = [var for var in var_nodes if var.get('properties', {}).get('scope_id') == func_id]
            
            for param in expected_params:
                param_var_id = f"var_{param}_{func_id}"
                param_found = any(var.get('id') == param_var_id for var in param_vars)
                assert param_found, f"Parameter {param} not found as variable in function scope"
            
            print(f"✓ Function parameter handling correct ({len(expected_params)} parameters)")
            return True
        
        return asyncio.run(run_test())

    def test_cross_scope_variable_usage(self):
        """Test cross-scope variable usage and script execution order."""
        print("\nTesting cross-scope variable usage...")
        
        async def run_test():
            # Extract from helper script
            nodes, relationships = await self.extract_file(self.test_dir / "helper_script.m")
            
            # Find USES relationships
            uses_rels = [rel for rel in relationships if rel.get('type') == 'USES']
            
            # Should have USES relationships for variables
            assert len(uses_rels) > 0, "Should have USES relationships"
            
            for rel in uses_rels:
                source_id = rel.get('source_id', '')
                target_id = rel.get('target_id', '')
                
                # Source should be script or function
                assert rel.get('source_type') in ['Script', 'Function'], f"USES source should be Script or Function: {rel.get('source_type')}"
                
                # Target should be variable
                assert rel.get('target_type') == 'Variable', f"USES target should be Variable: {rel.get('target_type')}"
                assert 'var_' in target_id, f"USES target should be a variable: {target_id}"
            
            print(f"✓ Cross-scope variable usage working correctly ({len(uses_rels)} USES relationships)")
            return True
        
        return asyncio.run(run_test())

    @classmethod
    def tearDownClass(cls):
        """Clean up test files."""
        import shutil
        if cls.test_dir.exists():
            shutil.rmtree(cls.test_dir)

if __name__ == "__main__":
    unittest.main()
