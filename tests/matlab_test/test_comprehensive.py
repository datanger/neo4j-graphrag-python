#!/usr/bin/env python3
"""
Comprehensive test suite for MATLAB code extractor with latest features.

This test suite covers:
1. Scope-specific variable handling (each script/function has its own variable nodes)
2. All relationship types: CALLS, USES, DEFINES, MODIFIES, ASSIGNED_TO
3. Cross-scope variable relationships
4. Function and script parsing
5. Variable assignment and modification tracking
"""

import os
import sys
import asyncio
import unittest
from pathlib import Path

# Add the project root to the path
sys.path.insert(0, str(Path(__file__).parent.parent.parent))

from unittest.mock import MagicMock
from typing import Dict, List, Set, Tuple, Any

from neo4j_graphrag.experimental.components.code_extractor.matlab.matlab_extractor import MatlabExtractor
from neo4j_graphrag.experimental.components.schema import GraphSchema, NodeType, PropertyType, RelationshipType
from neo4j_graphrag.experimental.components.types import TextChunk, TextChunks, DocumentInfo

class MockLLM:
    """Mock LLM for testing."""
    async def generate(self, prompt: str) -> str:
        return "Mock description generated by LLM"

class TestComprehensiveMatlabExtraction(unittest.TestCase):
    """Comprehensive test suite for MATLAB code extraction."""

    @classmethod
    def setUpClass(cls):
        """Set up the test environment."""
        cls.test_dir = Path(__file__).parent / "examples"
        cls.test_dir.mkdir(exist_ok=True)

        # Create comprehensive test files
        cls.create_test_files()

        # Set up extractor
        cls.mock_llm = MockLLM()
        cls.extractor = MatlabExtractor(
            llm=cls.mock_llm,
            debug=True,
            enable_post_processing=True
        )

    @classmethod
    def create_test_files(cls):
        """Create comprehensive test MATLAB files."""

        # Test file 1: Main script with variables and function calls
        with open(cls.test_dir / "main_script.m", "w") as f:
            f.write("""
% Main script demonstrating comprehensive relationship patterns

% Define script-level variables
x = 10;
y = x + 5;
z = y * 2;

% Call functions
result1 = helper_function(x);
[modified_x, modified_y] = modify_variables(x, y);

% Call another script
run('helper_script.m');

% Use variables in calculations
final_result = modified_x + modified_y + z;

% Display results
display_results(final_result, result1);
""")

        # Test file 2: Helper function
        with open(cls.test_dir / "helper_function.m", "w") as f:
            f.write("""
function result = helper_function(input)
    % Helper function that processes input
    x = input * 2;  % Same variable name as main script
    y = x + 10;     % Same variable name as main script
    result = y;
end
""")

        # Test file 3: Variable modification function
        with open(cls.test_dir / "modify_variables.m", "w") as f:
            f.write("""
function [out1, out2] = modify_variables(in1, in2)
    % Function that modifies input variables
    out1 = in1 * 2;
    out2 = in2 + 10;

    % Internal variable with same name as inputs
    x = out1 + out2;
    y = x / 2;
end
""")

        # Test file 4: Helper script
        with open(cls.test_dir / "helper_script.m", "w") as f:
            f.write("""
% Helper script with its own variables

% Script-level variables
a = 42;
b = a / 2;
c = b + 10;

% Call a function
d = helper_function(c);

% Use variables
result = a + b + c + d;
""")

        # Test file 5: Display function
        with open(cls.test_dir / "display_results.m", "w") as f:
            f.write("""
function display_results(varargin)
    % Function that displays multiple results
    for i = 1:length(varargin)
        fprintf('Result %d: %f\\n', i, varargin{i});
    end
end
""")

    def setUp(self):
        """Set up before each test."""
        # Reset the global registry for clean tests
        MatlabExtractor.reset_global_registry()

    async def extract_file(self, file_path: Path) -> Tuple[List[Dict], List[Dict]]:
        """Extract nodes and relationships from a MATLAB file."""
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()

        chunk = TextChunk(
            text=content,
            index=0,
            metadata={"file_path": str(file_path)}
        )

        # Create schema
        schema = GraphSchema(
            node_types=[
                NodeType(
                    label="Function",
                    description="A code function definition",
                    properties=[
                        PropertyType(name="name", type="STRING", description="Name of the function"),
                        PropertyType(name="file_path", type="STRING", description="Path to the file containing the function"),
                        PropertyType(name="scope_id", type="STRING", description="ID of the scope where this function is defined"),
                        PropertyType(name="scope_type", type="STRING", description="Type of scope: 'script' or 'function'"),
                    ],
                ),
                NodeType(
                    label="Variable",
                    description="A variable used in the code",
                    properties=[
                        PropertyType(name="name", type="STRING", description="Name of the variable"),
                        PropertyType(name="file_path", type="STRING", description="Path to the file where the variable is defined"),
                        PropertyType(name="scope_id", type="STRING", description="ID of the scope where this variable is defined"),
                        PropertyType(name="scope_type", type="STRING", description="Type of scope: 'script' or 'function'"),
                    ],
                ),
                NodeType(
                    label="Script",
                    description="A code script file",
                    properties=[
                        PropertyType(name="name", type="STRING", description="Name of the script"),
                        PropertyType(name="file_path", type="STRING", description="Path to the script file"),
                    ],
                ),
            ],
            relationship_types=[
                RelationshipType(label="CALLS", description="A function or script calls another function or script"),
                RelationshipType(label="USES", description="A function or script uses a variable"),
                RelationshipType(label="DEFINES", description="A function or script defines a variable"),
                RelationshipType(label="MODIFIES", description="A function or script modifies a variable"),
                RelationshipType(label="ASSIGNED_TO", description="A variable is assigned to another variable"),
            ],
            patterns=[
                ("Function", "CALLS", "Function"),
                ("Function", "CALLS", "Script"),
                ("Script", "CALLS", "Function"),
                ("Script", "CALLS", "Script"),
                ("Function", "USES", "Variable"),
                ("Script", "USES", "Variable"),
                ("Function", "DEFINES", "Variable"),
                ("Script", "DEFINES", "Variable"),
                ("Script", "DEFINES", "Function"),
                ("Function", "MODIFIES", "Variable"),
                ("Script", "MODIFIES", "Variable"),
                ("Variable", "ASSIGNED_TO", "Variable"),
            ]
        )

        result = await self.extractor.extract_for_chunk(schema, "", chunk)

        # Convert to dictionaries for easier testing
        nodes = [dict(node) for node in result.nodes]
        relationships = [dict(rel) for rel in result.relationships]

        return nodes, relationships

    def test_scope_specific_variables(self):
        """Test that variables are scope-specific (same name in different scopes = different nodes)."""
        print("\n=== TESTING SCOPE-SPECIFIC VARIABLES ===")

        # Extract main script
        nodes, relationships = asyncio.run(self.extract_file(self.test_dir / "main_script.m"))

        # Find all variable nodes
        variable_nodes = [n for n in nodes if n['label'] == 'Variable']

        # Group variables by name
        variables_by_name = {}
        for node in variable_nodes:
            name = node['properties']['name']
            if name not in variables_by_name:
                variables_by_name[name] = []
            variables_by_name[name].append({
                'id': node['id'],
                'scope_id': node['properties']['scope_id'],
                'scope_type': node['properties']['scope_type']
            })

        print(f"Found {len(variable_nodes)} variable nodes")
        print("Variables by name:")
        for name, instances in variables_by_name.items():
            print(f"  {name}: {len(instances)} instances")
            for inst in instances:
                print(f"    - {inst['id']} (scope: {inst['scope_type']} {inst['scope_id']})")

        # Check for variables with same name in different scopes
        multi_scope_vars = {name: instances for name, instances in variables_by_name.items() if len(instances) > 1}

        print(f"\nVariables in multiple scopes: {len(multi_scope_vars)}")
        for name, instances in multi_scope_vars.items():
            print(f"  {name}: {len(instances)} scopes")
            scope_ids = [inst['scope_id'] for inst in instances]
            self.assertGreater(len(set(scope_ids)), 1, f"Variable {name} should be in different scopes")

        # Verify that each variable has a unique ID
        variable_ids = [n['id'] for n in variable_nodes]
        unique_ids = set(variable_ids)
        self.assertEqual(len(variable_ids), len(unique_ids), "All variable nodes should have unique IDs")

        print("✓ Scope-specific variable handling works correctly")

    def test_relationship_patterns(self):
        """Test that all relationship patterns are correctly created."""
        print("\n=== TESTING RELATIONSHIP PATTERNS ===")

        # 创建提取器
        extractor = MatlabExtractor(llm=self.mock_llm, debug=True)
        
        # 创建schema
        schema = GraphSchema(
            node_types=[
                NodeType(
                    label="Function",
                    description="A code function definition",
                    properties=[
                        PropertyType(name="name", type="STRING", description="Name of the function"),
                        PropertyType(name="file_path", type="STRING", description="Path to the file containing the function"),
                        PropertyType(name="scope_id", type="STRING", description="ID of the scope where this function is defined"),
                        PropertyType(name="scope_type", type="STRING", description="Type of scope: 'script' or 'function'"),
                    ],
                ),
                NodeType(
                    label="Variable",
                    description="A variable used in the code",
                    properties=[
                        PropertyType(name="name", type="STRING", description="Name of the variable"),
                        PropertyType(name="file_path", type="STRING", description="Path to the file where the variable is defined"),
                        PropertyType(name="scope_id", type="STRING", description="ID of the scope where this variable is defined"),
                        PropertyType(name="scope_type", type="STRING", description="Type of scope: 'script' or 'function'"),
                    ],
                ),
                NodeType(
                    label="Script",
                    description="A code script file",
                    properties=[
                        PropertyType(name="name", type="STRING", description="Name of the script"),
                        PropertyType(name="file_path", type="STRING", description="Path to the script file"),
                    ],
                ),
            ],
            relationship_types=[
                RelationshipType(label="CALLS", description="A function or script calls another function or script"),
                RelationshipType(label="USES", description="A function or script uses a variable"),
                RelationshipType(label="DEFINES", description="A function or script defines a variable"),
                RelationshipType(label="MODIFIES", description="A function or script modifies a variable"),
                RelationshipType(label="ASSIGNED_TO", description="A variable is assigned to another variable"),
            ],
            patterns=[
                ("Function", "CALLS", "Function"),
                ("Function", "CALLS", "Script"),
                ("Script", "CALLS", "Function"),
                ("Script", "CALLS", "Script"),
                ("Function", "USES", "Variable"),
                ("Script", "USES", "Variable"),
                ("Function", "DEFINES", "Variable"),
                ("Script", "DEFINES", "Variable"),
                ("Script", "DEFINES", "Function"),
                ("Function", "MODIFIES", "Variable"),
                ("Script", "MODIFIES", "Variable"),
                ("Variable", "ASSIGNED_TO", "Variable"),
            ]
        )
        
        # 处理所有文件
        all_nodes = []
        all_relationships = []
        
        for m_file in self.test_dir.glob("*.m"):
            with open(m_file, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # 创建文本块
            chunk = TextChunk(
                text=content,
                index=0,
                metadata={"file_path": str(m_file), "file_name": m_file.name, "code_type": "matlab"}
            )
            
            doc_info = DocumentInfo(
                path=str(m_file),
                metadata={"name": m_file.name}
            )
            
            # 处理文件
            result = asyncio.run(extractor.run(
                chunks=TextChunks(chunks=[chunk]),
                schema=schema,
                document_info=doc_info,
                enable_post_processing=False  # 先不启用后处理
            ))
            
            # 收集节点和关系
            all_nodes.extend(result.graph.nodes)
            all_relationships.extend(result.graph.relationships)
        
        # 应用后处理
        from neo4j_graphrag.experimental.components.types import Neo4jGraph
        combined_graph = Neo4jGraph(nodes=all_nodes, relationships=all_relationships)
        final_graph = MatlabExtractor.post_process_cross_file_relationships(combined_graph)
        
        # 转换为简单格式
        unique_nodes = []
        for node in final_graph.nodes:
            unique_nodes.append({
                'id': node.id,
                'label': node.label,
                'properties': node.properties
            })
        
        unique_relationships = []
        for rel in final_graph.relationships:
            unique_relationships.append({
                'start_node_id': rel.start_node_id,
                'end_node_id': rel.end_node_id,
                'type': rel.type,
                'properties': rel.properties
            })

        print(f"Total unique nodes: {len(unique_nodes)}")
        print(f"Total unique relationships: {len(unique_relationships)}")

        # Group relationships by type
        rels_by_type = {}
        for rel in unique_relationships:
            rel_type = rel['type']
            if rel_type not in rels_by_type:
                rels_by_type[rel_type] = []
            rels_by_type[rel_type].append(rel)

        print("\nRelationships by type:")
        for rel_type, rels in rels_by_type.items():
            print(f"  {rel_type}: {len(rels)} relationships")

        # Test specific relationship patterns
        expected_patterns = [
            ("Script", "CALLS", "Function"),
            ("Script", "CALLS", "Script"),
            ("Script", "DEFINES", "Variable"),
            ("Function", "DEFINES", "Variable"),
            ("Script", "USES", "Variable"),
            ("Function", "USES", "Variable"),
            ("Variable", "ASSIGNED_TO", "Variable"),
        ]

        for source_type, rel_type, target_type in expected_patterns:
            found = False
            for rel in unique_relationships:
                source_node = next((n for n in unique_nodes if n['id'] == rel['start_node_id']), None)
                target_node = next((n for n in unique_nodes if n['id'] == rel['end_node_id']), None)

                if (source_node and target_node and
                    source_node['label'] == source_type and
                    rel['type'] == rel_type and
                    target_node['label'] == target_type):
                    found = True
                    break

            self.assertTrue(found, f"Missing relationship pattern: {source_type} -[{rel_type}]-> {target_type}")
            print(f"  ✓ Found {source_type} -[{rel_type}]-> {target_type}")

        print("✓ All expected relationship patterns found")

    def test_variable_assignment_tracking(self):
        """Test that variable assignments are correctly tracked."""
        print("\n=== TESTING VARIABLE ASSIGNMENT TRACKING ===")

        # Extract main script
        nodes, relationships = asyncio.run(self.extract_file(self.test_dir / "main_script.m"))

        # Find ASSIGNED_TO relationships
        assigned_to_rels = [r for r in relationships if r['type'] == 'ASSIGNED_TO']

        print(f"Found {len(assigned_to_rels)} ASSIGNED_TO relationships")

        for rel in assigned_to_rels:
            source_node = next((n for n in nodes if n['id'] == rel['start_node_id']), None)
            target_node = next((n for n in nodes if n['id'] == rel['end_node_id']), None)

            if source_node and target_node:
                print(f"  {source_node['properties']['name']} -> {target_node['properties']['name']}")
                print(f"    Source: {source_node['id']}")
                print(f"    Target: {target_node['id']}")

        # Verify that we have assignments
        self.assertGreater(len(assigned_to_rels), 0, "Should have at least one ASSIGNED_TO relationship")

        print("✓ Variable assignment tracking works correctly")

    def test_function_parameter_handling(self):
        """Test that function parameters are correctly handled."""
        print("\n=== TESTING FUNCTION PARAMETER HANDLING ===")

        # Extract helper function
        nodes, relationships = asyncio.run(self.extract_file(self.test_dir / "helper_function.m"))

        # Find function node
        function_nodes = [n for n in nodes if n['label'] == 'Function']
        self.assertGreater(len(function_nodes), 0, "Should find at least one function")

        func_node = function_nodes[0]
        print(f"Function: {func_node['properties']['name']}")
        print(f"Parameters: {func_node['properties'].get('parameters', [])}")

        # Find DEFINES relationships from function to variables
        defines_rels = [r for r in relationships
                       if r['type'] == 'DEFINES' and r['start_node_id'] == func_node['id']]

        print(f"Function defines {len(defines_rels)} variables")

        for rel in defines_rels:
            target_node = next((n for n in nodes if n['id'] == rel['end_node_id']), None)
            if target_node:
                print(f"  - {target_node['properties']['name']}")

        # Verify that parameters are defined
        expected_params = ['input']
        for param in expected_params:
            param_found = any(
                n['properties']['name'] == param and n['properties']['scope_id'] == func_node['id']
                for n in nodes if n['label'] == 'Variable'
            )
            self.assertTrue(param_found, f"Parameter '{param}' should be defined by function")

        print("✓ Function parameter handling works correctly")

    def test_cross_scope_variable_usage(self):
        """Test that cross-scope variable usage is correctly tracked."""
        print("\n=== TESTING CROSS-SCOPE VARIABLE USAGE ===")

        # Extract all files to get cross-scope relationships
        all_nodes = []
        all_relationships = []

        for m_file in self.test_dir.glob("*.m"):
            nodes, relationships = asyncio.run(self.extract_file(m_file))
            all_nodes.extend(nodes)
            all_relationships.extend(relationships)

        # Remove duplicates
        unique_nodes = []
        seen_node_ids = set()
        for node in all_nodes:
            if node['id'] not in seen_node_ids:
                unique_nodes.append(node)
                seen_node_ids.add(node['id'])

        unique_relationships = []
        seen_rel_keys = set()
        for rel in all_relationships:
            key = (rel['start_node_id'], rel['end_node_id'], rel['type'])
            if key not in seen_rel_keys:
                unique_relationships.append(rel)
                seen_rel_keys.add(key)

        # Find USES relationships
        uses_rels = [r for r in unique_relationships if r['type'] == 'USES']

        print(f"Found {len(uses_rels)} USES relationships")

        for rel in uses_rels:
            source_node = next((n for n in unique_nodes if n['id'] == rel['start_node_id']), None)
            target_node = next((n for n in unique_nodes if n['id'] == rel['end_node_id']), None)

            if source_node and target_node:
                source_scope = source_node['properties'].get('scope_id', source_node['id'])
                target_scope = target_node['properties'].get('scope_id', target_node['id'])

                print(f"  {source_node['label']} {source_node['properties'].get('name', source_node['id'])} "
                      f"uses {target_node['properties']['name']} "
                      f"(scopes: {source_scope} -> {target_scope})")

        # Verify that we have cross-scope usage
        cross_scope_uses = 0
        for rel in uses_rels:
            source_node = next((n for n in unique_nodes if n['id'] == rel['start_node_id']), None)
            target_node = next((n for n in unique_nodes if n['id'] == rel['end_node_id']), None)

            if source_node and target_node:
                source_scope = source_node['properties'].get('scope_id', source_node['id'])
                target_scope = target_node['properties'].get('scope_id', target_node['id'])

                if source_scope != target_scope:
                    cross_scope_uses += 1

        print(f"Cross-scope USES relationships: {cross_scope_uses}")
        self.assertGreater(cross_scope_uses, 0, "Should have cross-scope variable usage")

        print("✓ Cross-scope variable usage tracking works correctly")

    @classmethod
    def tearDownClass(cls):
        """Clean up test files."""
        # Optionally clean up test files
        # for m_file in cls.test_dir.glob("*.m"):
        #     try:
        #         m_file.unlink()
        #     except:
        #         pass
        pass

if __name__ == '__main__':
    unittest.main()
