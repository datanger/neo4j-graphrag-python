 #!/usr/bin/env python3
"""
Updated test suite for MATLAB code extractor that matches the latest requirements.

This test suite covers the requirements specified in examples.md and kg_builder_from_code.py:
1. Scope-specific variable handling with proper ID format: var_{变量名}_{作用域ID}
2. All relationship types: CALLS, USES, DEFINES, MODIFIES, ASSIGNED_TO
3. Cross-scope variable relationships with execution order analysis
4. Function parameter handling (not cross-scope access)
5. Script execution order and dependency analysis
6. Proper node and relationship properties
"""

import os
import sys
import asyncio
import unittest
from pathlib import Path

# Add the project root to the path
sys.path.insert(0, str(Path(__file__).parent.parent.parent))

from unittest.mock import MagicMock
from typing import Dict, List, Set, Tuple, Any

from neo4j_graphrag.experimental.components.code_extractor.matlab.matlab_extractor import MatlabExtractor
from neo4j_graphrag.experimental.components.schema import GraphSchema, NodeType, PropertyType, RelationshipType
from neo4j_graphrag.experimental.components.types import TextChunk, TextChunks, DocumentInfo, Neo4jGraph

class MockLLM:
    """Mock LLM for testing."""
    async def generate(self, prompt: str) -> str:
        return "Mock description generated by LLM"

class TestUpdatedMatlabRequirements(unittest.TestCase):
    """Test suite for MATLAB code extraction with updated requirements."""

    @classmethod
    def setUpClass(cls):
        """Set up the test environment."""
        cls.test_dir = Path(__file__).parent / "examples"
        cls.test_dir.mkdir(exist_ok=True)

        # Create test files that match the requirements
        cls.create_requirement_test_files()

        # Set up extractor
        cls.mock_llm = MockLLM()
        cls.extractor = MatlabExtractor(
            llm=cls.mock_llm,
            debug=True,
            enable_post_processing=True,
            entry_script_path=str(cls.test_dir / "entry_script.m")
        )

    @classmethod
    def create_requirement_test_files(cls):
        """Create test MATLAB files that match the requirements in examples.md."""

        # Entry script for execution order analysis
        with open(cls.test_dir / "entry_script.m", "w") as f:
            f.write("""
% Entry script that defines execution order
% This script calls other scripts in a specific order

% Define some global variables
global shared_var;
shared_var = 100;

% Call scripts in order
setup_script;
main_script;
helper_script;

% Use variables from previous scripts
final_result = config + shared_var;
""")

        # Setup script (executes first)
        with open(cls.test_dir / "setup_script.m", "w") as f:
            f.write("""
% Setup script that runs first
% This script defines variables that will be used by other scripts

% Define configuration variables
config = 42;
base_value = 10;

% Call a function
setup_result = setup_function(base_value);

% Define variables for other scripts
shared_config = struct('param1', 1, 'param2', 2);
""")

        # Setup function
        with open(cls.test_dir / "setup_function.m", "w") as f:
            f.write("""
function result = setup_function(input)
    % Setup function that processes input
    result = input * 2;
    
    % Local variable with same name as other scopes
    x = result + 5;
    y = x * 2;
end
""")

        # Main script (executes second)
        with open(cls.test_dir / "main_script.m", "w") as f:
            f.write("""
% Main script that demonstrates various relationship patterns
% This script uses variables from setup_script and calls other functions

% Use variables from setup_script (cross-scope access)
initial_value = config;  % Uses config from setup_script
base_val = base_value;   % Uses base_value from setup_script

% Define script-level variables
x = initial_value + 5;
y = x + base_val;
z = y * 2;

% Call functions
result1 = helper_function(x);
[modified_x, modified_y] = modify_variables(x, y);

% Call another script
run('helper_script.m');

% Use variables in calculations
final_result = modified_x + modified_y + z;

% Display results
display_results(final_result, result1);
""")

        # Helper function
        with open(cls.test_dir / "helper_function.m", "w") as f:
            f.write("""
function result = helper_function(input)
    % Helper function that processes input
    % This function has its own scope with variables named x, y
    x = input * 2;  % Same variable name as main script, but different scope
    y = x + 10;     % Same variable name as main script, but different scope
    result = y;
end
""")

        # Variable modification function
        with open(cls.test_dir / "modify_variables.m", "w") as f:
            f.write("""
function [out1, out2] = modify_variables(in1, in2)
    % Function that modifies input variables
    % Parameters in1, in2 are not cross-scope access, they are parameter passing
    out1 = in1 * 2;
    out2 = in2 + 10;

    % Internal variable with same name as other scopes
    x = out1 + out2;  % Same name as other scopes, but different node
    y = x / 2;        % Same name as other scopes, but different node
end
""")

        # Helper script (executes third)
        with open(cls.test_dir / "helper_script.m", "w") as f:
            f.write("""
% Helper script with its own variables
% This script can access variables from setup_script and main_script

% Script-level variables
a = 42;
b = a / 2;
c = b + 10;

% Use variables from previous scripts (cross-scope access)
setup_val = config;      % From setup_script
main_val = final_result; % From main_script

% Call a function
d = helper_function(c);

% Use variables
result = a + b + c + d + setup_val + main_val;
""")

        # Display function
        with open(cls.test_dir / "display_results.m", "w") as f:
            f.write("""
function display_results(varargin)
    % Function that displays multiple results
    for i = 1:length(varargin)
        fprintf('Result %d: %f\\n', i, varargin{i});
    end
end
""")

        # Script dependency test files
        with open(cls.test_dir / "script1.m", "w") as f:
            f.write("""
% Script that calls script2 and uses its variables
disp('This is script1.m executing');

% Define variables
val1 = 5;

% Call script2
script2;

% Use variables from script2 (cross-scope access)
val2 = val1 + val_from_script2;  % Uses variable from script2
final_result = val_from_script2 * 2;  % Another cross-scope usage
""")

        with open(cls.test_dir / "script2.m", "w") as f:
            f.write("""
% Script that defines variables for script1 to use
disp('This is script2.m executing');

% Define variables to be used by script1
val_from_script2 = 20;
shared_data = [1, 2, 3, 4, 5];
""")

    def setUp(self):
        """Set up before each test."""
        # Reset the global registry for clean tests
        MatlabExtractor.reset_global_registry()

    async def extract_all_files(self) -> Tuple[List[Dict], List[Dict]]:
        """Extract nodes and relationships from all MATLAB files."""
        # Create schema that matches the requirements
        schema = GraphSchema(
            node_types=[
                NodeType(
                    label="Function",
                    description="A code function definition",
                    properties=[
                        PropertyType(name="name", type="STRING", description="Name of the function"),
                        PropertyType(name="file_path", type="STRING", description="Path to the file containing the function"),
                        PropertyType(name="parameters", type="STRING", description="List of function parameters"),
                        PropertyType(name="returns", type="STRING", description="List of return values"),
                        PropertyType(name="description", type="STRING", description="Function description"),
                    ],
                ),
                NodeType(
                    label="Variable",
                    description="A variable used in the code",
                    properties=[
                        PropertyType(name="name", type="STRING", description="Name of the variable"),
                        PropertyType(name="file_path", type="STRING", description="Path to the file where the variable is defined"),
                        PropertyType(name="scope_id", type="STRING", description="ID of the scope where this variable is defined"),
                        PropertyType(name="scope_type", type="STRING", description="Type of scope: 'script' or 'function'"),
                        PropertyType(name="line_range", type="LIST", description="Line range where the variable is used"),
                    ],
                ),
                NodeType(
                    label="Script",
                    description="A code script file",
                    properties=[
                        PropertyType(name="name", type="STRING", description="Name of the script"),
                        PropertyType(name="file_path", type="STRING", description="Path to the script file"),
                        PropertyType(name="description", type="STRING", description="Script description"),
                    ],
                ),
            ],
            relationship_types=[
                RelationshipType(label="CALLS", description="A function or script calls another function or script"),
                RelationshipType(label="USES", description="A function or script uses a variable"),
                RelationshipType(label="DEFINES", description="A function or script defines a variable"),
                RelationshipType(label="MODIFIES", description="A function or script modifies a variable"),
                RelationshipType(label="ASSIGNED_TO", description="A variable is assigned to another variable"),
            ],
            patterns=[
                ("Function", "CALLS", "Function"),
                ("Function", "CALLS", "Script"),
                ("Script", "CALLS", "Function"),
                ("Script", "CALLS", "Script"),
                ("Function", "USES", "Variable"),
                ("Script", "USES", "Variable"),
                ("Function", "DEFINES", "Variable"),
                ("Script", "DEFINES", "Variable"),
                ("Script", "DEFINES", "Function"),
                ("Function", "MODIFIES", "Variable"),
                ("Script", "MODIFIES", "Variable"),
                ("Variable", "ASSIGNED_TO", "Variable"),
            ]
        )

        # Process all files
        all_nodes = []
        all_relationships = []
        
        for m_file in self.test_dir.glob("*.m"):
            with open(m_file, 'r', encoding='utf-8') as f:
                content = f.read()
            
            chunk = TextChunk(
                text=content,
                index=0,
                metadata={"file_path": str(m_file), "file_name": m_file.name, "code_type": "matlab"}
            )
            
            doc_info = DocumentInfo(
                path=str(m_file),
                metadata={"name": m_file.name}
            )
            
            # Process file
            result = await self.extractor.run(
                chunks=TextChunks(chunks=[chunk]),
                schema=schema,
                document_info=doc_info,
                enable_post_processing=True,
                rebuild_data=True
            )
            
            # Collect nodes and relationships
            all_nodes.extend(result.graph.nodes)
            all_relationships.extend(result.graph.relationships)

        # Convert to dictionaries for easier testing
        nodes = [dict(node) for node in all_nodes]
        relationships = [dict(rel) for rel in all_relationships]

        return nodes, relationships

    def test_variable_id_format(self):
        """Test that variable IDs follow the required format: var_{变量名}_{作用域ID}."""
        print("\n=== TESTING VARIABLE ID FORMAT ===")
        
        nodes, relationships = asyncio.run(self.extract_all_files())
        
        # Find all variable nodes
        variable_nodes = [n for n in nodes if n['label'] == 'Variable']
        
        print(f"Found {len(variable_nodes)} variable nodes")
        
        # Check ID format
        for node in variable_nodes:
            node_id = node['id']
            name = node['properties']['name']
            scope_id = node['properties']['scope_id']
            
            # Check if ID follows the required format
            expected_prefix = f"var_{name}_"
            self.assertTrue(
                node_id.startswith(expected_prefix),
                f"Variable ID {node_id} should start with {expected_prefix}"
            )
            
            # Check if scope_id is included in the ID
            self.assertIn(
                scope_id, node_id,
                f"Variable ID {node_id} should contain scope_id {scope_id}"
            )
            
            print(f"✓ Variable {name}: {node_id} (scope: {scope_id})")

    def test_scope_isolation(self):
        """Test that variables with the same name in different scopes are different nodes."""
        print("\n=== TESTING SCOPE ISOLATION ===")
        
        nodes, relationships = asyncio.run(self.extract_all_files())
        
        # Find all variable nodes
        variable_nodes = [n for n in nodes if n['label'] == 'Variable']
        
        # Group variables by name
        variables_by_name = {}
        for node in variable_nodes:
            name = node['properties']['name']
            if name not in variables_by_name:
                variables_by_name[name] = []
            variables_by_name[name].append({
                'id': node['id'],
                'scope_id': node['properties']['scope_id'],
                'scope_type': node['properties']['scope_type'],
                'file_path': node['properties']['file_path']
            })
        
        # Check for variables that appear in multiple scopes
        multi_scope_vars = {name: instances for name, instances in variables_by_name.items() if len(instances) > 1}
        
        print(f"Variables in multiple scopes: {len(multi_scope_vars)}")
        
        for name, instances in multi_scope_vars.items():
            print(f"\nVariable '{name}' appears in {len(instances)} scopes:")
            scope_ids = set()
            for inst in instances:
                print(f"  - {inst['id']} (scope: {inst['scope_type']} {inst['scope_id']}, file: {inst['file_path']})")
                scope_ids.add(inst['scope_id'])
            
            # Verify that each instance has a unique scope_id
            self.assertEqual(
                len(scope_ids), len(instances),
                f"Variable {name} should have unique scope_id for each instance"
            )

    def test_cross_scope_relationships(self):
        """Test cross-scope variable relationships with execution order."""
        print("\n=== TESTING CROSS-SCOPE RELATIONSHIPS ===")
        
        nodes, relationships = asyncio.run(self.extract_all_files())
        
        # Find cross-scope USES relationships
        cross_scope_uses = [
            rel for rel in relationships 
            if rel['type'] == 'USES' and 
            'usage_type' in rel['properties'] and 
            'cross_scope' in rel['properties']['usage_type']
        ]
        
        print(f"Found {len(cross_scope_uses)} cross-scope USES relationships")
        
        for rel in cross_scope_uses:
            source_id = rel['start_node_id']
            target_id = rel['end_node_id']
            properties = rel['properties']
            
            print(f"\nCross-scope USES: {source_id} -> {target_id}")
            print(f"  Usage type: {properties.get('usage_type', 'unknown')}")
            print(f"  Source script: {properties.get('source_script', 'unknown')}")
            print(f"  Target script: {properties.get('target_script', 'unknown')}")
            print(f"  Execution order: {properties.get('execution_order', 'unknown')}")
            
            # Verify that cross-scope relationships have execution order info
            self.assertIn(
                'execution_order', properties,
                f"Cross-scope relationship should have execution_order property"
            )
            
            # Verify that source and target scripts are different
            if 'source_script' in properties and 'target_script' in properties:
                self.assertNotEqual(
                    properties['source_script'], properties['target_script'],
                    f"Cross-scope relationship should be between different scripts"
                )

    def test_assigned_to_relationships(self):
        """Test ASSIGNED_TO relationships between variables."""
        print("\n=== TESTING ASSIGNED_TO RELATIONSHIPS ===")
        
        nodes, relationships = asyncio.run(self.extract_all_files())
        
        # Find ASSIGNED_TO relationships
        assigned_to_rels = [rel for rel in relationships if rel['type'] == 'ASSIGNED_TO']
        
        print(f"Found {len(assigned_to_rels)} ASSIGNED_TO relationships")
        
        for rel in assigned_to_rels:
            source_id = rel['start_node_id']
            target_id = rel['end_node_id']
            properties = rel['properties']
            
            print(f"\nASSIGNED_TO: {source_id} -> {target_id}")
            print(f"  Type: {properties.get('type', 'unknown')}")
            print(f"  Line number: {properties.get('line_number', 'unknown')}")
            
            # Verify that both source and target are variable nodes
            source_node = next((n for n in nodes if n['id'] == source_id), None)
            target_node = next((n for n in nodes if n['id'] == target_id), None)
            
            self.assertIsNotNone(source_node, f"Source node {source_id} should exist")
            self.assertIsNotNone(target_node, f"Target node {target_id} should exist")
            self.assertEqual(source_node['label'], 'Variable', f"Source should be a Variable node")
            self.assertEqual(target_node['label'], 'Variable', f"Target should be a Variable node")

    def test_function_parameter_handling(self):
        """Test that function parameters are not treated as cross-scope access."""
        print("\n=== TESTING FUNCTION PARAMETER HANDLING ===")
        
        nodes, relationships = asyncio.run(self.extract_all_files())
        
        # Find function nodes
        function_nodes = [n for n in nodes if n['label'] == 'Function']
        
        for func_node in function_nodes:
            func_name = func_node['properties']['name']
            func_id = func_node['id']
            
            # Find parameter definitions for this function
            param_defs = [
                rel for rel in relationships 
                if rel['type'] == 'DEFINES' and 
                rel['start_node_id'] == func_id and
                rel['properties'].get('type') == 'parameter'
            ]
            
            print(f"\nFunction {func_name} has {len(param_defs)} parameters:")
            for rel in param_defs:
                param_id = rel['end_node_id']
                param_node = next((n for n in nodes if n['id'] == param_id), None)
                if param_node:
                    param_name = param_node['properties']['name']
                    print(f"  - {param_name}: {param_id}")
                    
                    # Verify that parameters are defined within the function scope
                    self.assertEqual(
                        param_node['properties']['scope_id'], func_id,
                        f"Parameter {param_name} should be in function scope {func_id}"
                    )

    def test_script_execution_order(self):
        """Test script execution order analysis."""
        print("\n=== TESTING SCRIPT EXECUTION ORDER ===")
        
        nodes, relationships = asyncio.run(self.extract_all_files())
        
        # Find script nodes
        script_nodes = [n for n in nodes if n['label'] == 'Script']
        
        print(f"Found {len(script_nodes)} script nodes:")
        for script in script_nodes:
            print(f"  - {script['properties']['name']}: {script['id']}")
        
        # Find script-to-script CALLS relationships
        script_calls = [
            rel for rel in relationships 
            if rel['type'] == 'CALLS' and
            any(n['id'] == rel['start_node_id'] and n['label'] == 'Script' for n in nodes) and
            any(n['id'] == rel['end_node_id'] and n['label'] == 'Script' for n in nodes)
        ]
        
        print(f"\nFound {len(script_calls)} script-to-script CALLS relationships:")
        for rel in script_calls:
            source_id = rel['start_node_id']
            target_id = rel['end_node_id']
            source_name = next(n['properties']['name'] for n in nodes if n['id'] == source_id)
            target_name = next(n['properties']['name'] for n in nodes if n['id'] == target_id)
            print(f"  - {source_name} -> {target_name}")

    def test_relationship_properties(self):
        """Test that relationships have the required properties."""
        print("\n=== TESTING RELATIONSHIP PROPERTIES ===")
        
        nodes, relationships = asyncio.run(self.extract_all_files())
        
        print(f"Found {len(relationships)} total relationships")
        
        # Check properties for each relationship type
        rel_types = set(rel['type'] for rel in relationships)
        
        for rel_type in rel_types:
            type_rels = [rel for rel in relationships if rel['type'] == rel_type]
            print(f"\n{rel_type} relationships ({len(type_rels)}):")
            
            for rel in type_rels[:3]:  # Show first 3 examples
                properties = rel['properties']
                print(f"  - {rel['start_node_id']} -> {rel['end_node_id']}")
                print(f"    Properties: {list(properties.keys())}")
                
                # Verify that relationships have appropriate properties
                if rel_type == 'USES':
                    self.assertIn('usage_type', properties, "USES relationships should have usage_type")
                elif rel_type == 'DEFINES':
                    self.assertIn('type', properties, "DEFINES relationships should have type")
                elif rel_type == 'ASSIGNED_TO':
                    self.assertIn('type', properties, "ASSIGNED_TO relationships should have type")

    @classmethod
    def tearDownClass(cls):
        """Clean up test files."""
        # Optionally remove test files
        pass

if __name__ == "__main__":
    # Run the tests
    unittest.main(verbosity=2)