#!/usr/bin/env python3
"""
Updated test suite for MATLAB code extractor that matches the latest requirements.

This test suite covers the requirements specified in requirements.py:
1. Scope-specific variable handling with proper ID format: var_{变量名}_{作用域ID}
2. All relationship types: CALLS, USES, DEFINES, MODIFIES, ASSIGNED_TO
3. Cross-scope variable relationships with execution order analysis
4. Function parameter handling (not cross-scope access)
5. Script execution order and dependency analysis
6. Proper node and relationship properties
"""

import os
import sys
import asyncio
import unittest
from pathlib import Path

# Add the project root to the path
sys.path.insert(0, str(Path(__file__).parent.parent.parent))

from unittest.mock import MagicMock
from typing import Dict, List, Set, Tuple, Any

from neo4j_graphrag.experimental.components.code_extractor.matlab.matlab_extractor import MatlabExtractor
from neo4j_graphrag.experimental.components.code_extractor.matlab.schema import SCHEMA
from neo4j_graphrag.experimental.components.types import TextChunk, TextChunks, DocumentInfo, Neo4jGraph

class MockLLM:
    """Mock LLM for testing."""
    async def generate(self, prompt: str) -> str:
        return "Mock description generated by LLM"

class TestUpdatedMatlabRequirements(unittest.TestCase):
    """Test suite for MATLAB code extraction with updated requirements."""

    @classmethod
    def setUpClass(cls):
        """Set up the test environment."""
        cls.test_dir = Path(__file__).parent / "examples"
        cls.test_dir.mkdir(exist_ok=True)

        # Create test files that match the requirements
        cls.create_requirement_test_files()

        # Set up extractor
        cls.mock_llm = MockLLM()
        cls.extractor = MatlabExtractor(
            llm=cls.mock_llm,
            enable_post_processing=True,
            entry_script_path=str(cls.test_dir / "entry_script.m")
        )

    @classmethod
    def create_requirement_test_files(cls):
        """Create test MATLAB files that match the requirements in requirements.py."""

        # Entry script for execution order analysis
        with open(cls.test_dir / "entry_script.m", "w") as f:
            f.write("""
% Entry script that defines execution order
% This script calls other scripts in a specific order

% Define some global variables
global shared_var;
shared_var = 100;

% Call scripts in order
setup_script;
main_script;
helper_script;

% Use variables from previous scripts
final_result = config + shared_var;
""")

        # Setup script (executes first)
        with open(cls.test_dir / "setup_script.m", "w") as f:
            f.write("""
% Setup script that runs first
% This script defines variables that will be used by other scripts

% Define configuration variables
config = 42;
base_value = 10;

% Call a function
setup_result = setup_function(base_value);

% Define variables for other scripts
shared_config = struct('param1', 1, 'param2', 2);
""")

        # Setup function
        with open(cls.test_dir / "setup_function.m", "w") as f:
            f.write("""
function result = setup_function(input)
    % Setup function that processes input
    result = input * 2;
    
    % Local variable with same name as other scopes
    x = result + 5;
    y = x * 2;
end
""")

        # Main script (executes second)
        with open(cls.test_dir / "main_script.m", "w") as f:
            f.write("""
% Main script that demonstrates various relationship patterns
% This script uses variables from setup_script and calls other functions

% Use variables from setup_script (cross-scope access)
initial_value = config;  % Uses config from setup_script
base_val = base_value;   % Uses base_value from setup_script

% Define script-level variables
x = initial_value + 5;
y = x + base_val;
z = y * 2;

% Call functions
result1 = helper_function(x);
[modified_x, modified_y] = modify_variables(x, y);

% Call another script
run('helper_script.m');

% Use variables in calculations
final_result = modified_x + modified_y + z;

% Display results
display_results(final_result, result1);
""")

        # Helper function
        with open(cls.test_dir / "helper_function.m", "w") as f:
            f.write("""
function result = helper_function(input)
    % Helper function that processes input
    % This function has its own scope with variables named x, y
    x = input * 2;  % Same variable name as main script, but different scope
    y = x + 10;     % Same variable name as main script, but different scope
    result = y;
end
""")

        # Variable modification function
        with open(cls.test_dir / "modify_variables.m", "w") as f:
            f.write("""
function [out1, out2] = modify_variables(in1, in2)
    % Function that modifies input variables
    % Parameters in1, in2 are not cross-scope access, they are parameter passing
    out1 = in1 * 2;
    out2 = in2 + 10;

    % Internal variable with same name as other scopes
    x = out1 + out2;  % Same name as other scopes, but different node
    y = x / 2;        % Same name as other scopes, but different node
end
""")

        # Helper script (executes third)
        with open(cls.test_dir / "helper_script.m", "w") as f:
            f.write("""
% Helper script with its own variables
% This script can access variables from setup_script and main_script

% Script-level variables
a = 42;
b = a / 2;
c = b + 10;

% Use variables from previous scripts (cross-scope access)
setup_val = config;      % From setup_script
main_val = final_result; % From main_script

% Call a function
d = helper_function(c);

% Use variables
result = a + b + c + d + setup_val + main_val;
""")

        # Display function
        with open(cls.test_dir / "display_results.m", "w") as f:
            f.write("""
function display_results(varargin)
    % Function that displays multiple results
    for i = 1:length(varargin)
        fprintf('Result %d: %f\\n', i, varargin{i});
    end
end
""")

        # Script dependency test files
        with open(cls.test_dir / "script1.m", "w") as f:
            f.write("""
% Script1 that calls script2 and uses its variables
script2;  % Call script2 first
val_from_script2;  % Use variable from script2
result = val_from_script2 * 2;
""")

        with open(cls.test_dir / "script2.m", "w") as f:
            f.write("""
% Script2 that defines variables for script1
val_from_script2 = 42;
other_var = 100;
""")

    def setUp(self):
        """Set up before each test."""
        # Reset the global registry for clean tests
        MatlabExtractor.reset_global_registry()

    async def extract_all_files(self) -> Tuple[List[Dict], List[Dict]]:
        """Extract nodes and relationships from all test files."""
        # Create TextChunks from all test files
        chunks = []
        test_files = [
            "entry_script.m", "setup_script.m", "setup_function.m", 
            "main_script.m", "helper_function.m", "modify_variables.m",
            "helper_script.m", "display_results.m", "script1.m", "script2.m"
        ]
        
        for file_name in test_files:
            file_path = self.test_dir / file_name
            if file_path.exists():
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()

                chunk = TextChunk(
                    text=content,
                    index=len(chunks),
                    metadata={"file_path": str(file_path)}
                )
                chunks.append(chunk)

        # Use the run method to process all chunks at once
        text_chunks = TextChunks(chunks=chunks)
        result = await self.extractor.run(text_chunks, schema=SCHEMA)
        
        return result.graph.nodes, result.graph.relationships

    def test_variable_id_format(self):
        """Test that variables follow the required ID format: var_{变量名}_{作用域ID}."""
        print("\nTesting variable ID format...")
        
        async def run_test():
            nodes, _ = await self.extract_all_files()
            
            # Find all variable nodes
            variable_nodes = [node for node in nodes if node.label == 'Variable']
            
            for node in variable_nodes:
                node_id = node.id
                properties = node.properties
                name = properties.get('name', '')
                scope_id = properties.get('scope_id', '')
                
                # Check ID format
                expected_id_format = f"var_{name}_{scope_id}"
                assert node_id == expected_id_format, f"Variable ID format mismatch: {node_id} != {expected_id_format}"
                
                # Check that scope_id and scope_type are present
                assert 'scope_id' in properties, f"Missing scope_id in variable {node_id}"
                assert 'scope_type' in properties, f"Missing scope_type in variable {node_id}"
                
                # Check scope_type values
                scope_type = properties.get('scope_type', '')
                assert scope_type in ['script', 'function'], f"Invalid scope_type: {scope_type}"
            
            print(f"✓ All {len(variable_nodes)} variable nodes follow correct ID format")
            return True
        
        return asyncio.run(run_test())

    def test_scope_isolation(self):
        """Test that variables with same names in different scopes are separate nodes."""
        print("\nTesting scope isolation...")
        
        async def run_test():
            nodes, _ = await self.extract_all_files()
            
            # Find all variable nodes
            variable_nodes = [node for node in nodes if node.label == 'Variable']
            
            # Group variables by name
            variables_by_name = {}
            for node in variable_nodes:
                name = node.properties.get('name', '')
                if name not in variables_by_name:
                    variables_by_name[name] = []
                variables_by_name[name].append(node)
            
            # Check that variables with same names in different scopes have different IDs
            for name, nodes_with_same_name in variables_by_name.items():
                if len(nodes_with_same_name) > 1:
                    node_ids = [node.id for node in nodes_with_same_name]
                    scope_ids = [node.properties.get('scope_id') for node in nodes_with_same_name]
                    
                    # All IDs should be different
                    assert len(set(node_ids)) == len(node_ids), f"Duplicate IDs for variable {name}: {node_ids}"
                    
                    # All scope_ids should be different
                    assert len(set(scope_ids)) == len(scope_ids), f"Duplicate scope_ids for variable {name}: {scope_ids}"
                    
                    print(f"✓ Variable '{name}' properly isolated across {len(nodes_with_same_name)} scopes")
            
            return True
        
        return asyncio.run(run_test())

    def test_cross_scope_relationships(self):
        """Test cross-scope variable relationships with execution order analysis."""
        print("\nTesting cross-scope relationships...")
        
        async def run_test():
            nodes, relationships = await self.extract_all_files()
            
            # Find script nodes
            script_nodes = [node for node in nodes if node.label == 'Script']
            script_ids = [node.id for node in script_nodes]
            
            # Find variable nodes
            variable_nodes = [node for node in nodes if node.label == 'Variable']
            
            # Check for cross-scope USES relationships
            cross_scope_uses = []
            for rel in relationships:
                if (rel.type == 'USES' and 
                    rel.start_node_type == 'Script' and 
                    rel.end_node_type == 'Variable'):
                    
                    source_id = rel.start_node_id
                    target_id = rel.end_node_id
                    
                    # Check if this is a cross-scope relationship
                    source_scope = source_id.replace('script_', '')
                    target_scope = target_id.split('_', 2)[2] if '_' in target_id else ''
                    
                    if source_scope != target_scope:
                        cross_scope_uses.append(rel)
            
            # Should have cross-scope relationships
            assert len(cross_scope_uses) > 0, "No cross-scope USES relationships found"
            print(f"✓ Found {len(cross_scope_uses)} cross-scope USES relationships")
            
            return True
        
        return asyncio.run(run_test())

    def test_assigned_to_relationships(self):
        """Test ASSIGNED_TO relationships between variables."""
        print("\nTesting ASSIGNED_TO relationships...")
        
        async def run_test():
            nodes, relationships = await self.extract_all_files()
            
            # Find ASSIGNED_TO relationships
            assigned_to_rels = [rel for rel in relationships if rel.type == 'ASSIGNED_TO']
            
            for rel in assigned_to_rels:
                source_id = rel.start_node_id
                target_id = rel.end_node_id
                
                # Both source and target should be variables
                assert 'var_' in source_id, f"ASSIGNED_TO source should be a variable: {source_id}"
                assert 'var_' in target_id, f"ASSIGNED_TO target should be a variable: {target_id}"
            
            print(f"✓ Found {len(assigned_to_rels)} ASSIGNED_TO relationships")
            return True
        
        return asyncio.run(run_test())

    def test_function_parameter_handling(self):
        """Test that function parameters are handled correctly (not cross-scope access)."""
        print("\nTesting function parameter handling...")
        
        async def run_test():
            nodes, relationships = await self.extract_all_files()
            
            # Find function nodes
            function_nodes = [node for node in nodes if node.label == 'Function']
            
            for func_node in function_nodes:
                func_id = func_node.id
                properties = func_node.properties
                parameters = properties.get('parameters', '')
                
                if parameters:
                    # Function should have parameter variables defined in its scope
                    param_vars = [node for node in nodes 
                                 if (node.label == 'Variable' and 
                                     node.properties.get('scope_id') == func_id)]
                    
                    # Check that parameters are defined in function scope
                    param_names = [p.strip() for p in parameters.split(',')]
                    for param_name in param_names:
                        param_var_id = f"var_{param_name}_{func_id}"
                        param_vars_found = [v for v in param_vars if v.id == param_var_id]
                        assert len(param_vars_found) > 0, f"Parameter {param_name} not found in function scope"
            
            print(f"✓ Function parameter handling correct for {len(function_nodes)} functions")
            return True
        
        return asyncio.run(run_test())

    def test_script_execution_order(self):
        """Test script execution order and dependency analysis."""
        print("\nTesting script execution order...")
        
        async def run_test():
            nodes, relationships = await self.extract_all_files()
            
            # Find CALLS relationships between scripts
            script_calls = [rel for rel in relationships 
                           if (rel.type == 'CALLS' and 
                               rel.start_node_type == 'Script' and 
                               rel.end_node_type == 'Script')]
            
            # Should have script-to-script calls
            assert len(script_calls) > 0, "No script-to-script CALLS relationships found"
            
            for rel in script_calls:
                source_id = rel.start_node_id
                target_id = rel.end_node_id
                
                # Check that both are script nodes
                assert source_id.startswith('script_'), f"Source should be a script: {source_id}"
                assert target_id.startswith('script_'), f"Target should be a script: {target_id}"
            
            print(f"✓ Found {len(script_calls)} script-to-script CALLS relationships")
            return True
        
        return asyncio.run(run_test())

    def test_relationship_properties(self):
        """Test that relationships have proper properties."""
        print("\nTesting relationship properties...")
        
        async def run_test():
            nodes, relationships = await self.extract_all_files()
            
            for rel in relationships:
                rel_type = rel.type
                
                # Check that relationship has required properties
                assert hasattr(rel, 'start_node_id'), f"Missing start_node_id in {rel_type} relationship"
                assert hasattr(rel, 'end_node_id'), f"Missing end_node_id in {rel_type} relationship"
                assert hasattr(rel, 'start_node_type'), f"Missing start_node_type in {rel_type} relationship"
                assert hasattr(rel, 'end_node_type'), f"Missing end_node_type in {rel_type} relationship"
                
                # Check that types match the schema patterns
                source_type = rel.start_node_type
                target_type = rel.end_node_type
                
                # Verify this pattern is allowed in the schema
                pattern = (source_type, rel_type, target_type)
                assert pattern in SCHEMA.patterns, f"Invalid relationship pattern: {pattern}"
            
            print(f"✓ All {len(relationships)} relationships have proper properties")
            return True
        
        return asyncio.run(run_test())

    @classmethod
    def tearDownClass(cls):
        """Clean up test files."""
        import shutil
        if cls.test_dir.exists():
            shutil.rmtree(cls.test_dir)

if __name__ == "__main__":
    unittest.main()